# qqq
Подготовка к экзамену по предмету "Алгоритмические языки" 2020
=====================
#### 1. Двусвязный список: поиск элемента по значению, вставка элемента, удаление элемента. Реализация функции удаления элемента из двусвязного списка. Основные методы std::list. Пример работы с std::list
---
![list](https://prog-cpp.ru/wp-content/uploads/2014/04/DLS-add.png)

- O(1) - одна операция для всех возможных входных данных
- O(n) - операция на каждый элемент (цикл)
- O(n^2) - сложность порядка n квадрат (цикл в цикле)
- O(log n) - как будто массив у нас отсортирован ( в отличие от предыдущих, где худший вариант)

Каждый узел двунаправленого линейного списка содержит два поля указателей-
на следующий и предыдущий узлы. УКазатель на предыдущий узел для начального равен NULL.
УКазатель на следующий для конечного -  NULL.

##### В общем виде узел выглядит:
```cpp
struct list
{
    int field; // поле данных
    struct list* next; // указатель на следующий элемент
    struct list* prev; // указатель на предыдущий элемент
};
```
##### Основные действия, проводимые над узлами:
- инициализация списка
- добавление узла в список
- удаление узла из списка
- удаление корня
- вывод элементов
- вывод жлементов в обратном порядке
- взаимообмен двух элементов списка

##### Инициализация списка предназначена дял создания корневого узла списка, у которого поля указателей
на следующие и предыдущий узлы содержат нулевое значение.
```cpp
struct list * init (int a) // а - значение первого узла
{
    struct list *lst = new struct list();
    lst -> field = a;
    lst -> next = NULL; //указатель на следующий элемент (его нет)
    lst -> prev = NULL; //указатель на предыдущий элемент (его нет)
    return (lst);
}
```
##### Функция добавления узла принимает:
- данные о добавляемом элементе
- указатель на узел, после которого происходит добавление
##### Само добавление включает в себя:
- создание узла и заполнение его данных
- изменение указателей элементов, соседних с новым
- функция выводит адрес добавляемого узла
```cpp
struct list * addlem (list *lst, int number)
{
    list* temp = new list; // создание нового узла

	temp->next = temp->prev = nullptr; // обнул указателей на другие узлы
	temp->field = number;  // занесение в нов узел данных 

	if (lst->next == nullptr) {
		lst->next = temp;
		temp->prev = lst;
	}
	else {
		temp->next = lst->next;  // нов узел соед со след
		temp->prev = lst;	     // нов узел соед с пред
		lst->next = temp;        // пред соед с нов
		temp->next->prev = temp; // след соед с нов
	}

	return temp; // возвр нов узел
}
```
##### Удаление элемента списка
В качестве аргументов передается указатель на удаляемый узел.
Происходит обмен указателями и функция возвращает указатель на узел,
следующий за удаляемым.
```cpp
strust list * delete (list*lst)
{
    struct list *prev;
    struct list *next;
    prev = lst->prev;
    next = lst->next;
    if (prev != NULL)
        prev->next = lst->next;
    if (next != NULL)
        next->prev = lst->prev;
    return (prev);
}
```
##### Поиск элемента с определенным значением
В функцию передается указатель на корень списка и значение элемента,
который нам нужно найти.
```cpp
bool search(list *lst, int number)
{
  struct list *p;
  p = lst;

  while (p != NULL)
  {
    if (p->field == number)
        return true
    p = p->next;
  }
  return false;
}
```
##### Оценки сложности (N - размер контейнера/количество элементов):
- Вставка/удаление - O(1)
- Поиск элемента - O(N)
##### LIST
Этот контейнер быстро добавляет и удаляет значения, потому что не приходится
перемещать элементы между собой, а нужно только грамотно манипулировать
указателями.

##### Этот контейнер находится в библиотеке:
```cpp
#include <list>
```
##### Cоздание:
```cpp
list <тип данных> имя контейнера = { список, аргументов};
```
##### Основные методы:
- emplace/push_front (создает(без лишнего копирования)/копирует(перемещает) элемент в начало списка)
- emplace/push_back (создает/копирует(перемещает) элемент в конец списка)
- emplace/insert (создает/копирует(перемещает) элемент в указанную позицию)
- pop_back, pop_front, erase, clear (удаление с конца, с начала, удаление с известной позиции или промежутка, удаление всех элментов(size = 0))
- swap (Обменивает содержимое контейнера с контейнером x)
- front, back (обратиться к первому и последнему элементу)
##### Основные операции:
- remove - удаляет элементы сравнимые с передаваемым значением (то есть по значение, а не по позиции)
- sort - сортирует элементы списка (по умолчанию в порядке возрастания)
- reverse - меняет порядок элементов в списке на противоположный
- merge - слияние двух отсортированных списков, второй список остается пустым.
- splice - переносит элементы из одного списка в другой с указанной позиции (второй список становиться пустым)
Копирование не происходит.

```cpp
#include <iostream>
#include <list>
int main() {
    std::list<int> mylist1 = {1,2,3,4};
    std::list<int> mylist2 = {10,20,30};

    auto it = mylist1.begin();
    ++it;
    mylist1.splice (it, mylist2);
    // mylist1 1 10 20 30 2 3 4
    // mylist2 (empty)
    // "it" still points to 2 (the 5th element)

    mylist1.erase(mylist1.begin()); //mylist1 10 20 30 2 3 4

    mylist2.push_back(23); //mylist2 23
    mylist2.push_back(23); //mylist2 23 23

    mylist2.swap(mylist1); //mylist2 10 20 30 2 3 4  mylist1 23 23

    mylist2.sort(); //mylist2 2 3 4 10 20 30
}
```

#### 2. Класс std::map. Внутренняя реализация map, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::map
---
![map](https://qph.fs.quoracdn.net/main-qimg-12cd34c071b5ed07220d841c3c0b2090)

Отсортированный ассоциативный контейнер, содержащий пары ключ-значение с уникальными ключами. Ключи отсортированы с помощью функции сравнения Compare. Операции поиска, удаления и вставки имеют логарифмическую сложность. Карты обычно реализованы в виде красно-черных деревьев.

Красно-черное дерево - это бинарное дерево поиска с дополнительным параметром цветом в каждом узле. В соответствии с накладываемыми на узлы дерева ограничения ни один простой путь от корня в КЧД не отличается от другого по длине более чем в два раза, таким образом КЧД являются приближенно сбалансированными.
Значения могут быть получены непосредственно по ключу с помощью оператора [].
При добавлении нового элемента контейнер будет отсортирован по возрастанию.

##### Map находится в библиотеке:
```cpp
#include <map>
```
##### Cоздание map:
```cpp
map <тип данных ключа, тип данных значени> имя;
```
При создании map все его элементы будут иметь значение нуля или сразу инициализированы.
```cpp
map <string, string> pair = {{Alena, Taehyung}, {JK, Te}};
```
##### Основные методы:
- insert - вставка элемента/элементов. В последнем случае сложность O(N * log(size + N)). Поскольку ключи элемента в карте уникальны, операция вставки проверяет, есть ли у каждого вставленного элемента ключ, эквивалентный ключу элемента, уже находящегося в контейнере, и, если это так, элемент не вставляется, возвращая итератор.
```cpp
std::map<char,int> mymap;
// first insert function version (single parameter):
mymap.insert ( std::pair<char,int>('a',100) );
mymap.insert ( std::pair<char,int>('z',200) );

std::pair<std::map<char,int>::iterator,bool> ret;
ret = mymap.insert ( std::pair<char,int>('z',500) );
if (ret.second==false) {
    std::cout << "element 'z' already existed";
    std::cout << " with a value of " << ret.first->second << '\n';
}

// second insert function version (with hint position):
std::map<char,int>::iterator it = mymap.begin();
mymap.insert (it, std::pair<char,int>('b',300));  // max efficiency inserting
mymap.insert (it, std::pair<char,int>('c',400));  // no max efficiency inserting

// third insert function version (range insertion):
std::map<char,int> anothermap;
anothermap.insert(mymap.begin(),mymap.find('c'));
// mymap contains [a,100], [b, 300], [c, 400], [z, 200] anothermap contains [a,100], [b,300]
```

- emplace - Вставляет новый элемент в карту, если его ключ уникален. Этот новый элемент создается на месте, а не копируется или перемещается.
```cpp
std::map<char, int> mymap;
mymap.emplace('a', 1);
mymap.emplace('b', 2);
```
- erase - удаление элемента по ключу, по итератору или в диапозоне.
```cpp
std::map<char, int> mymap;
mymap['a'] = 1;
mymap['b'] = 2;
mymap.erase('a');
```
- swap - обменивает содержимое контейнера на содержимое x , который является другой картой того же типа. Размеры могут отличаться.
- clear - удаление всех элементов из карты.
- find - ищет в контейнере элемент с указанным ключем, возвращает итератор на найденный элемент. (Если ключа нет возвращает end())

##### Оценка сложности:
- Вставка/удаление - O(log N)
- Поиск элемента по ключу - O(log N)

#### 3. Класс std::set. Внутренняя реализация set, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::set
---
![set](https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/500px-Red-black_tree_example.svg.png)

std::set - множество. Элементы уникальны, а так же сравниваются и сортируются при добавлении по возрастанию. Чаще всего реализовано так же как и std::map с помощью красно-черных деревьев.
##### Библиотека и создание:
```cpp
#include <set>

set <тип> имя{2,3,4};
```

##### Основные методы:
- insert
- erase (удаляет элемент (по итератору), все элементы по значению или диапазон элементов)
- swap
- clear
- emplace
- find (поиск элемента по значению. выводит: местонахождение(итератор) или значение на конец контейнера)
- lower_bound / upper_bound (находит элемент >= ключу / находит элемент > ключа)
```cpp
имя.lower_bound(key);
```
Сложность такая же как и у std::map в силу использования одинаковой структуры данных

###### Пример работы:
```cpp
    std::set<int> myset;
    std::set<int>::iterator it;
    std::pair<std::set<int>::iterator,bool> ret;

    // set some initial values:
    for (int i=1; i<=5; ++i)
        myset.insert(i*10);    // set: 10 20 30 40 50

    ret = myset.insert(20);               // no new element inserted

    if (ret.second==false)
        it=ret.first;  // "it" now points to element 20

    myset.insert (it,25);

    int myints[]= {5,10,15};              // 10 already in set, not inserted
    myset.insert (myints,myints+3);       // myset: 5 10 15 20 25 30 40 50

    myset.erase(10); // myset: 5 15 20 25 30 50
    it = myset.begin();
    it++;

    myset.erase(it); // myset: 5 20 25 30 50
    it = myset.find(25);
    myset.erase(it, myset.end()); // myset: 5 20

    std::set<int> myset2 {1, 2, 3};
    myset2.emplace(4);

    myset1.swap(myset2)
 for (auto& x:mymap)
   std::cout << x.first << " " << x.second;
```

#### 4. Класс std::unordered_map. Внутренняя реализация unordered_map, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std:: unordered_map
---
unordered_map - является ассоциативным контейнером, который содержит пары ключ-значение с уникальными ключами. Поиск, вставка и удаление выполняются за константное время.
Внутренне unordered_map реализована с использованием хэш-таблицы, ключ хэшируется в индексы хэш-таблицы, поэтому производительность структуры данных во многом зависит от хэш-функции, но в среднем вставка и удаление из хэш-таблицы составляет О(1).
Неупорядоченные контейнеры реализуют оператор прямого доступа[], который позволяет осуществлять прямой доступ к значению, использую его ключв качестве аргументов. Никакие два элемента не могу иметь эквивалентные ключи.
![hash_table](http://upload.wikimedia.org/wikipedia/commons/thumb/c/c2/HASHTB08.svg/362px-HASHTB08.svg.png)

### Начало работы
```cpp
#include <unordered_map>

std::unordered_map <тип ключа, тип значения> имя;
имя[ключ]= значение;

 //или сразу

std::unordered_map <bool, int> mymap2 = { {true, 4}, {false, 43}};
```
##### Основные методы:
- emplace
- emplace_hint (возможно вставить в определенную позицию)
```cpp
unordered_map.emplace_hint(позиция, клюс, значение)
```
- insert
- erase (удаляет из контейнера один или несколько элементов)
- clear (зачищает контейнер)
- swap (обменивается сожержимым)
- find (возвращает итератор на найденный элемент или итератор на конец контейнера)

Можно вывести непосредственно ключ и значение:
```cpp
std::cout <<got->first << "is" << got->second; // got - итератор на пару
```

##### Пример
```cpp
#include <iostream>
#include <unordered_map>
int main()
{
    std::unordered_map <bool, int> mymap;
    mymap[false]=3;
    mymap[true] = 17;

   mymap.insert(std::make_pair<bool,int> (false, 4));

   std::unordered_map <bool, int> mymap2;
       mymap[false]=43;
       mymap[true] = 54;

   mymap.insert(mymap2.begin(), mymap2.end());

   mymap.swap(mymap2);

   mymap2.erase (false);

   mymap.erase(mymap.begin());

   mymap2.emplace(false, 83);

   mymap2.erase(mymap2.begin(), mymap2.end()); //удаление с позиции по позицию (не включительно)

   for (auto& x:mymap)
   std::cout << x.first << " " << x.second;
}
```
#### 5. Класс std::vector. Внутренняя реализация vector, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::vector. Особенность std::vector<bool>.
---
std :: vector - динамический массив. Как и массивы, используются последовательные участки памяти для своих элементов. Размер может изменяться автоматически, а размер автоматически обрабатывается контейнером.
![vector](https://qph.fs.quoracdn.net/main-qimg-d2696c877d001f9e11c316bc1c5412ac)
##### Начало работы
```cpp
#include <vector>

vector <тип данных> имя = { 2,4,4};

vector <тип данных> имя(количество ячеек);

vector <тип данных> имя;
имя.reserve(количество ячеек);
```
##### Обращение к элементу
```cpp
#include <vector>

vector <int> my = { 2,4,5};
int a = my[1]; // a = 4
int b = my.at(2); //b = 5.  Проверяет находится ли n в пределах допустимых элементов в векторе, выбрасывая out_of_range, [] не проверяют
```
##### Основные методы:
- emplace - создание и вставка элемента на заданную позицию (О(n)).
- emplace_back - создание и вставка в конец (O(1)).
- push_back - вставка элемента в конец (О(1)).
- insert - вставка элемента в указанную позицию(если указан итератор, то после той ячейки, на которую он указывает) (O(n)). НЕ очень эффективна, так как приходится перемещать все элементы после той позиции на их новые позиции.
- swap - обмен содержимым с другим вектором (О(n)).
- erase - удаление элемента с указанной позиции или элементов из диапазона (O(n)).
- clear - удаление всех элементов вектора (O(n)).
- size - возвращает размер вектора (O(n)).
- resize - изменяет размер вектора (O(n)). Удаляет элементы лишние или добавляет те, что указаны (автоматически 0)
- capacity - возвращает количество элементов, на которые хватит зарезервированной памяти.
- reserve - резервирует области памяти для указанного количества элементов.
- assign - заменяет текущее значение вектора на введенное (изменяя размер вектора)

##### Пример
```cpp
#include <iostream>
#include <vector>

int main(){
    std::vector<int> my;

    for(size_t i = 0; i<10; ++i)
        my.push_back(i);

    my.erase(my.begin()+5); // удаление шестого элемента
    my.erase(my.begin(), my.begin()+3); //удаление первых трех элементов

    my.insert(my.begin(), 43);

    my.resize(5);

    std::vector<int> my2 = { 2,4,5};
    my2.swap(my);

    for ( size_t i = 0; i<my.size(); ++i)
        std::cout << my.at(i);
}
```
##### Особенности std::vector<bool>:
Cпециализация std::vector, более эффективно использующая память путем храненения булевых значений в каждом бите (в обычном векторе резервируется для одного элемента минмум 1 байт, а в этом 1 битом, то есть меньше в 8 раз). Так же предоставляет особый метод - flip, для инвертирования всех значений массива.
Все экземпляры true становятся false и наоборот.

```cpp
std::vector <bool> my;
my.flip();
```
#### 6. Парадигмы ООП. Полиморфизм (статический, динамический). Инкапсуляция. Наследование. Примеры.
---
ООП(объектно-ориентированное программирование) - методология программирования, в которой основными концепциями являются понятия объектов и классов. Парадигмы ООП: полиморфизм, наследование и инкапсуляция.

_Инкапсуляция_ - сокрытие информации, которое гарантирует что данные объекта и его методы используются по назначению. Использование инкапсуляции позволяет в дальнейшем изменять устройство классов без вреда для пользователя, при условии что открытый интерфейс объекта остается неизменным. С++ предоставляет 3 типа доступа - public, protected(доступ открыт классам, производным от данного) и private(только для функций класса или для друзей класса).

_Наследование_ - базирование одного типа данных (объекта или класса) на другом типе данных, способствующее повторному использованию уже существующего кода. Помимо повторного использования кода через наследование реализуются очевидные связи между классами, что способствует чистоте кода. С++ предлагает несколько типов наследования - public, protected, private и даже виртуальное наследование, каждое из которых реализует определенное отношение между классами.
![prim](https://codelessons.ru/wp-content/uploads/%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-c-1.png)

Если наследование public - использовать можно public и protected родительского класса.
Если наследование protected - пользовательсяяяя можно только свойствами (не функциями) родителя.
Чтобы использовать функции нужно разрешить это напрямую (и без круглых скобок, только имя),
а также разрешить нужно в публичном доступе (public).
```cpp

class Animals {
  public:
    int counter;  // общее кол животных
  protected:
    int zebras;
    int bears;
    int dogs;

    // функция вычисление общего количества животных
    count_animals() {
      counter = dogs + bears + zebras;
    }
    set_dogs(int count_of_dogs) {
      dogs = count_of_dogs;
    }
};

class Dog : private Animals {
  public:
    int count_dogs() {
      return dogs;  // использовали переменную dog
    }
    Animals :: set_dogs;

};

int main() {
    Dog jack;
    int k;
    cout << "Введите количество собак: "; cin >> k;

    jack.set_dogs(k);
    cout << "Количество собак равняется: "<< jack.count_dogs();
    return 0;
}
```
Модификатор наследования →	public	      private	  protected
Модификатор доступа ↓
 public	                    public	      public	 protected
 private	             нет доступа	нет доступа	 нет доступа
 protected	               protected	 protected	  protected

_Полиморфизм_ - cвойство, которое позволяет использовать одно и тоже имя функции
для решения двух и более схожих, но технически разных задач.
С++ допускае два типа полиморфизма: cтатический и динамический

_Статический полиморфизм_ представлен перегрузкой функций, аргументами по умолчанию и шаблонами. Таким образом функция ведет себя по разному в зависимости от параметров или типа, над которыми она работает.
_Динамический полиморфизм_ представлен наследованием и виртуальными функциями. Во время выполнения определяется какой метод необходимо использовать для соответствующего объекта в иерархии.
_Суть статического связывания:_ когда указатель одного типа ссылается на объект другого типа при наследовании классов, то выбор переопределенного метода определяется типом указателя, а не типом объекта.
_Суть динамического связывания:_ когда указатель одного типа ссылается на объект другого типа при наследовании классов, то выбор переопределенного метода определяется типом объекта, а не типом указателя, для этого переопределенный метод должен быть объявлен виртуальным в базовом классе.
###### Пример статического
![prim3](https://sun9-53.userapi.com/c204520/v204520534/368dd/CRm_JSE80OA.jpg)
##### Пример динамического
![prim4](https://sun9-20.userapi.com/c204520/v204520534/368e4/ygIhBNXfGnU.jpg)
#### 7. Разработка обобщенных типов: шаблоны С++. Инстанцирование. Спецификация шаблонов. Примеры.
---
##### Инстанцирование шаблона – это генерация кода функции или класса по шаблону для конкретных параметров.
Явное инстанцирование:
```cpp
std::cout  << function <double> (-2,4);
```
Оно используется:
- если инстанцирование шаблонов занимает слишком много времени
- если порядок компиляции должен быть абсолютно предсказуем
Неявное инстанцирование:
```cpp
std::cout  << function (-2,4);
```
##### Версия шаблона для конкретного аргумента шаблона называется специализацией.
Специализация - ручное указание реализации сущности для каких-либо конкретных параметров. Может быть полной или частичной.
```cpp
// Сама шаблонная функция. На ее месте может быть и класс
template <typename T1, typename T2>
void foo() {}

// Полная специализация
template <>
void foo<int, int>() {}

// Частичная специализация
template <typename T>
void foo<int, T>() {}
```
Шаблоны позволяют определить конструкции (функции, классы), которые используют определенные типы, но на момент написания кода точно не известно, что это будут за типы. Иными словами, шаблоны позволяют определить универсальные конструкции, которые не зависят от определенного типа. Любой шаблон начинается со слова template. После ключевого слова template идут угловые скобки — < >, в которых перечисляется список параметров шаблона. Каждому параметру должно предшествовать зарезервированное слово class или typename. . Некоторые примеры объявления шаблонов:
```cpp
template <class T> или template <typename T> или template <typename T1, typename T2>
```
Ключевое слово typename говорит о том, что в шаблоне будет использоваться встроенный тип данных, такой как: int, double,float, char и т. д. А ключевое слово class сообщает компилятору, что в шаблоне функции в качестве параметра будут использоваться пользовательские типы данных, то есть классы. Но не в коем случае не путайте параметр шаблона и шаблон класса. Если нам надо создать шаблон класса, с одним параметром типа int и char, шаблон класса будет выглядеть так:
```cpp
template <typename T>

class Name

{
//тело шаблона класса
};
```
где T — это параметр шаблона класса, который может принимать любой из встроенных типов данных, то, что нам и нужно.

А если параметр шаблона класса должен пользовательского типа, например типа Array, где Array — это класс, описывающий массив, шаблон класса будет иметь следующий вид:
```cpp
template <class T>
class Name
{
//тело шаблона класса
}
```
##### Пример
```cpp
#include <iostream>

using namespace std;

template < class T>

class
private:
    T a1[size];

public:
    Te()
    {
    for (int i=0; i < size; i++)
    {
    cout << endl << "Vvedite " << i + 1 << " chislo ";
    cin >> a1[i];
    }
}
void slog()
{
    for (int i=0; i < size-1; i++)

    {
    a1[0] = a1[0] + a1[i + 1];
    }
    cout << endl << "Rezyltat clogenia= " << a1[0];
}
};
int main()
{
    Te <int> F;
    F.slog();
    cout << endl;
}
```
#### 8. Итераторы: определение, назначение, преимущества. Итераторы прямого доступа, итераторы ввода, итераторы вывода, двунаправленные итераторы, прямой итератор. Примеры.
---
Итераторы обеспечивают доступ к элементам контейнера. С помощью итераторов очень удобно перебирать элементы. Итератор описывается типом iterator. Но для каждого контейнера конкретный тип итератора будет отличаться. Так, итератор для контейнера list<int> представляет тип list<int>::iterator, а итератор контейнера vector<int> представляет тип vector<int>::iterator и так далее.
Итератор - это не указатель.
##### Преимущества:
- Удобство в программировани (не нужно заранее знать количество элементов в контейнере)
- Динамическая обработка контейнера. Очень удобно добавлять или удалять элементы из контейнера
в любое время.

Начало работы:
 ```cpp
 #include <iterator>

 контейнер <его тип> :: iterator имя;
 ```
 ##### Виды итераторов
 - container::iterator (итератор для чтения/записи)
 - container::const_iterator (итератор только для чтения)

 Можно сразу  пределить, на что итератор будет указывать.
  ```cpp
 vector <int> my;
 vector <int> :: iterator it = my.begin();
  ```
Для получения итераторов контейнеры в C++ обладают такими функциями, как begin() и end(). Функция begin() возвращает итератор, который указывает на первый элемент контейнера (при наличии в контейнере элементов). Функция end() возвращает итератор, который указывает на следующую позицию после последнего элемента, то есть по сути на конец контейнера. Если контейнер пуст, то итераторы, возвращаемые обоими методами begin и end совпадают. Если итератор begin не равен итератору end, то между ними есть как минимум один элемент.

С итераторами можно проводить следующие операции:
- *iter: получение элемента, на который указывает итератор
- ++iter: перемещение итератора вперед для обращения к следующему элементу
- --iter: перемещение итератора назад для обращения к предыдущему элементу. Итераторы контейнера forward_list не поддерживают операцию декремента.
- iter1 == iter2: два итератора равны, если они указывают на один и тот же элемент
- iter1 != iter2: два итератора не равны, если они указывают на разные элементы _Если вы создали два одинаковых итератора на map, то при сравнивании они не будут одинаковыми_
- iter += 5 различные арифметические операции (*, /, +, -) НЕ РАБОТАЕТ С _list_ , _set_ , _map_ , НО работает с _vector_

##### Функция advance()
Перемещает итератор, передаваемый ей в качестве аргумента.
```cpp
advance(итератор, диапозон)
```
Диапазон может быть как отрицательным (-6), так и положительным (6), в зависимости от этого
итератор будет двигаться вперед или назад.

```cpp
#include <iostream>
#include <iterator>
#include <vector>
int main()
{
    std::vector<int> v{ 3, 1, 4 };

    auto vi = v.begin();

    std::advance(vi, 2);

    std::cout << *vi << '\n';  // 4
}
```
_Итераторы ввода_ - итераторы, который перемещается только в одном направлении и поддерживает только чтение.
Это итераторы, которые можно использовать в последовательных операциях ввода, где каждое значение, указанное итератором, читается только один раз, а затем увеличивается итератор.
##### Плюсы
- Удобство использования: входные итераторы могут использоваться только с однопроходными алгоритмами
- Сравнение равенства / неравенства: входной итератор можно сравнить на равенство с другим итератором.
- Разыменование: Итератор ввода может быть разыменован, используя операторы * и -> в качестве значения r, чтобы получить значение, сохраненное в позиции, на которую указывает итератор
- Увеличиваемый: Итератор ввода может быть увеличен, так что он ссылается на следующий элемент в последовательности, используя оператор ++ ().
- Swappable: значение, на которое указывают эти итераторы, можно заменить или обменять.

##### Минусы
- Мы не можем присвоить какое-либо значение местоположению, указанному этим итератором, оно может использоваться только для доступа к элементам, а не для назначения элементов
- Невозможно уменьшить: мы не можем использовать operator -- ()
- Невозможно использовать в алгоритмах, где нужно обрабатывать контейнер несколько раз
- Нельзя использовать арифметические операции
- Реляционные операторы: хотя входные итераторы могут использоваться с оператором равенства (==), но его нельзя использовать с другими реляционными операторами, такими как, <=.
```cpp
#include <iostream>
#include <vector>
using namespace std;
int main()
{
    vector<int> v1 = { 1, 2, 3, 4, 5 };
    // Объявление итератора
    vector<int>::iterator i1;
    for (i1 = v1.begin(); i1 != v1.end(); ++i1) {
        // Доступ к элементам с помощью итератора
        cout << (*i1) << " ";
    }
    return 0;
}
```
_Итераторы вывода_ - итераторы, допускающие запись и единичный проход в одном направлении. Им могут быть назначены значения в последовательности , но они не могут использоваться для доступа к значениям, в отличие от входных итераторов, которые делают обратный доступ к значениям и не могут быть назначены значения.
_Плюсы те же, что у итераторов ввода_
##### Минусы
- Только присваивание, без доступа: один из самых больших недостатков в том, что мы не можем получить доступ к выходным итераторам как rvalue. Таким образом, выходной итератор может изменять только тот элемент, на который он указывает, будучи использованным в качестве цели для назначения
- Все, кроме первого у итераторов ввода
```cpp
// C ++ программа для демонстрации выходного итератора
#include<iostream>
#include<vector>
using namespace std;
int main()

{
    vector<int>v1 = {1, 2, 3, 4, 5};
    // Объявление итератора
    vector<int>::iterator i1;
    for (i1=v1.begin();i1!=v1.end();++i1)
    {
        // Назначение элементов с помощью итератора
        *i1 = 1;
    }
    // v1 становится 1 1 1 1 1
    return 0;
}
```
_Итераторы прямого доступа_ - итератор, дополнительно к свойствам предыдущих двух, допускающий множественный проход в одном направлении.
##### Плюсы
- Удобство использования: выполнение операций на прямом итераторе с разыменованием никогда не делает его значение итератора неотменяемым, в результате это позволяет алгоритмам, использующим эту категорию итераторов, использовать несколько копий итератора для многократной передачи одних и тех же значений итератора. Таким образом, его можно использовать в многопроходных алгоритмах .
- Остальные как у итераторов ввода (без первого)
##### Минусы
- Невозможно уменьшить: мы не можем использовать operator -- ()
- Нельзя использовать арифметические операции
- Реляционные операторы: хотя входные итераторы могут использоваться с оператором равенства (==), но его нельзя использовать с другими реляционными операторами, такими как, <=.
- Использование оператора разыменования смещения ([]): прямые итераторы не поддерживают оператор разыменования смещения ([]), который используется для произвольного доступа.
```cpp
// C ++ программа для демонстрации прямого итератора
#include <iostream>
#include <vector>

using namespace std;
int main()
{
    vector<int> v1 = { 1, 2, 3, 4, 5 };
    // Объявление итератора
    vector<int>::iterator i1;
    for (i1 = v1.begin(); i1 != v1.end(); ++i1) {
        // Присваиваем значения местам, указанным итератором
        *i1 = 1;
    }
    for (i1 = v1.begin(); i1 != v1.end(); ++i1) {
        // Доступ к значениям в местах, указанных итератором
        cout << (*i1) << " ";
    }
    return 0;
}
```
_Двунаправленные итераторы_ - итератор, допускающий проход в обоих направлениях.
##### Плюсы
- Удобство использования: Поскольку итераторы прямого преобразования могут использоваться в многопроходных алгоритмах, т. Е. Алгоритме, который включает обработку контейнера несколько раз за различные проходы, поэтому двунаправленные итераторы также могут использоваться в многопроходных алгоритмах.
- Сравнение равенства / неравенства: входной итератор можно сравнить на равенство с другим итератором.
- Разыменование: Итератор ввода может быть разыменован, используя операторы * и -> в качестве значения r, чтобы получить значение, сохраненное в позиции, на которую указывает итератор
- Увеличиваемый и Уменьшаемый: Итератор ввода может быть увеличен, уменьшен, используя оператор ++ () или -- ().
- Swappable: значение, на которое указывают эти итераторы, можно заменить или обменять.

##### Минусы
- Нельзя использовать арифметические операции
- Реляционные операторы: хотя входные итераторы могут использоваться с оператором равенства (==), но его нельзя использовать с другими реляционными операторами, такими как, <=.
- Использование оператора разыменования смещения ([]): прямые итераторы не поддерживают оператор разыменования смещения ([]), который используется для произвольного доступа.

```cpp
// C ++ программа для демонстрации двунаправленного итератора
#include<iostream>
#include<list>

using namespace std;

int main()

{
    list<int>v1 = {1, 2, 3, 4, 5};
    // Объявление итератора
    list<int>::iterator i1;
    for (i1=v1.begin();i1!=v1.end();++i1)
    {

        // Присваиваем значения местам, указанным итератором
        *i1 = 1;
    }
    for (i1=v1.begin();i1!=v1.end();++i1)
    {
        // Доступ к значениям в местах, указанных итератором
        cout << (*i1) << " ";
    }
    return 0;
}
```
_Итератор произвольного доступа_ - итератор, допускающий произвольный доступ .
##### Плюсы
- Удобство использования: итераторы с произвольным доступом могут использоваться в многопроходных алгоритмах , т.е. алгоритме, который включает обработку контейнера несколько раз за различные проходы.
- Сравнение равенства / неравенства: входной итератор можно сравнить на равенство с другим итератором.
- Разыменование: Итератор ввода может быть разыменован, используя операторы * и -> в качестве значения r, чтобы получить значение, сохраненное в позиции, на которую указывает итератор
- Увеличиваемый и Уменьшаемый: Итератор ввода может быть увеличен, уменьшен, используя оператор ++ () или -- ().
- Swappable: значение, на которое указывают эти итераторы, можно заменить или обменять.
- Нельзя использовать арифметические операции
- Реляционные операторы: хотя входные итераторы могут использоваться с оператором равенства (==), но его нельзя использовать с другими реляционными операторами, такими как, <=.
- Использование оператора разыменования смещения ([]): прямые итераторы не поддерживают оператор разыменования смещения ([]), который используется для произвольного доступа.

```cpp
// C ++ программа для демонстрации итератора с произвольным доступом
#include<iostream>
#include<vector>
using namespace std;
int main()
{
    vector<int>v1 = {1, 2, 3, 4, 5};

    int i;
    // Доступ к элементам с использованием разыменования смещения
    // оператор []
    for(i=0;i<5;++i)
    {
        cout << v1[i] << " ";
    }
    return 0;
}
```
![iterators](https://github.com/sergejkoll/exam-preparation/blob/master/images/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-01-06%2013-25-01.png)
#### 9. Современный С++: auto, decltype, range base loop, nullptr, constexpr, enum class, if constexpr.
---
_auto_ - До С++11 ключевое слово использовалось для явного указания, что переменная должна иметь автоматическую продолжителность (создаваться в точке определения и уничтожаться в конце блока, в котором определена) Но, поскольку все переменные в новых версиях С++ по умолчанию умеют автоматическую продолжительность, то слово устарело. В С++11 auto позволяет не указывать тип переменной явно, говоря компилятору, чтобы он сам определил фактический тип переменной, на основе типа инициализируемого значения, так же  вы можете использовать auto вместо типа возвращаемого значения функции (но это очень опасно).
##### Примеры
```cpp
int subs(int a, int b)
{
    return b + a;
}

int main()
{
    auto result = subs(3,7); //функция вернет значение типа int и переменная тоже станет типа int
    return 0;
}
```
Переменные, объявленные без инициализации не могут использовать фичу, так как нет инициализируемого
значения и компилятор не может знать, какой тип данных присвоить переменной.
```cpp
void myswap(auto a, auto b)
{
    auto x = a;
    a=b;
    b=x;
}
```
Это не сработает, так как как компилятор не может определить типы данных для параметров функции a и b во время компиляции.

_decltype_ - проверяет объявленный тип объекта или тип выражения. Auto позволяет
вам объявлять переменную с определенным типом, тогда как decltype позволяет извлекать
тип из перпеменной, поэтому decltype является своего рода оператором, который оценивает
тип переданного выражения.

###### Пример
```cpp
int x = 5;
double y = 6.4;

decltype(x) foo; //int
decltype(y) foo; //double
decltype(x+y) foo; //double
```
_Range-based for loop_ - Выполняет цикл для диапазона. Используется в качестве более удобочитаемого эквивалента традиционному циклу for, работающему в диапазоне значений, таких как все элементы в контейнере.
##### Пример
```cpp
std::vector<int> v =  {0, 1, 2, 3, 4, 5};
for (auto i : v) // доступ по значению, тип i - int
    std::cout << i << ' ';
```
_nullptr_ - нулевое значение указателя (является константой r-value). Используется при работе с нулевыми укащателями, предпочтительнее, чем использование 0

```cpp
int *ptr = nullptr;
```
Можно использовать для вызова функции( в качестве аргумента - литерала)

```cpp
#include <iostream>

void do(int *ptr)
{
    if (ptr)
        std::cout<<"You passed in " << *ptr << "\n";
    else
         std::cout<<"You passed in a NULL pointer \n";
}

int main()
{
    do(nullptr); //теперь аргумент точно является нулевым указателем, а не целочисленным типом
}
```

В С++11 добавили тип данных std::nullptr_t, который находится в заголовочном файле <cstddef>.
Этот тип может принимать только значение nullptr, если полено, если вам нужно написать функцию, которая принимает аргумент nullptr.
_constexpr_ - спецификатор, который сообщает компилятору, что текущая переменная является константой времени компилации.
_Константы времени компиляции._ Их значения определяются во время компиляции программы. Например, переменная со значением силы тяжести на Земле является константой времени компиляции, так как мы её определяем во время написания программы (до начала её выполнения).
_Константы времени выполнения._ Их значения определяются только во время выполнения программы. Зависит от пользовательского ввода (который можно получить только во время выполнения программы) или зависит от значения, переданного в функцию (которое станет известным также во время выполнения программы).
##### Примеры
```cpp
constexpr int sum (int a, int b)
{
	return a + b;
}

void func()
{
	constexpr int c = sum (5, 12); // значение переменной будет посчитано на этапе компиляции
}
```
```cpp
struct A {
    constexpr static double x = 10.0;
    //const static double x = 10.0 - не скомпилируется
};

int main() {
    A a;
    return 0;
}
```
_enum_ (перечисление) - тип данных, где любое значение определяется как символьная константа.
При объявлении не выделяется память, а только после определения. Каждый перечислитель разделяется запятой,
а само перечисление заканчивается ;. Идентификаторы перечисления с большой буквы, а имена
перечислителей все большими буквами. Каждому перечислителю автоматически присваивается целочисленное значение
в зависимости от позиции в списке (от 0 и ++). Можно присвоить и свои значения, даже отрицательные (любые, не определенные
вами перечислители, будут иметь значения на единицу больше, чем значения предыдущих перечислителей),
но лучше не присваивать одинаковые, а лучше даже вообще свои не присваивать.
Поскольку значения перечислителей являются целые числа, то их можно присваивать целочисленным переменным, а также
выводит в консоль(как переменные int).
##### Пример
```cpp
#include <iostream>
enum Colors
{
    COLOR_PINK,    // 0
    COLOR_BROWN    // 1
}

int main()
{
    Colors color = 9; // ошибка. компилятор не будет неявно конвертировать целочисленное значение в значение перечислителя
    Colors color = stasic_cast<Colors>(9); // ошибки не будет но так делать не рекомендуется (явное преобразование типов)
    int my = COLOR_BROWN;
    std::cout << COLOR_BROWN; //конвертирует в int а затем выводится на экран
}
```
_enum class_ - перечисления с областью видимости, которые добавляют перечислениям локальную видимость со всеми ее правилами.
##### Пример
```cpp
#include <iostream>

int main(){
    enum class Fruits { //добавление class определяет перечесление с ограниченной областью видимости
        LEMON,//LEMON находтися внутри той же области видимости, что и FRUITS
        KIWI
    };

    enum class Colors {
        PINK,    //PINK находтися внутри той же области видимости, что и Colors
        GREY,
    };

    Fruits fruit = LEMON; //Lemon напрямую использовать нельзя, нужно использовать Fruits::LEMON
    Colors color = Colors::PINK;

    if(fruit == color) //ошибка, компилятор не знает, как сравнивать разные типы
    //если убрать class, то уже не будет ошибки в строчке с лимоном и со сравнением, а будет сравнивать эти переменные как целые числа
}
```
_if constexpr_ - if во время компиляции.
```cpp
template <typename T>
std::string str(T t) {
  if constexpr (std::is_same_v<T, std::string>) // строка или преобразуемый в строку
    return t;
  else
    return std::to_string(t);
}
```
Если использовать без constexpr, то компилятор выдаст ошибку, так как компилятор попытается
разобрать обе условные ветки и найдет ошибку в случае else. Он не сможет отбросить неправильный код.
Именно для этого и нужен constexpr, который будет исключать код и компилировать
только тот блок, который подходит условию.
#### 10. Современный С++: static_assert, initializer_list, default, final, override, using
---
_Стейтмент assert_ (или ещё «оператор проверочного утверждения») в C++ — это макрос препроцессора, который обрабатывает условное выражение во время выполнения.
Если условное выражение истинно, то ничего не происходит, если ложно, то выводится сообщение об
ошибке (содержит ложное условное выражение, имя файла и номер строки) и программа завершается.
Объявлен в заголовочном файле <cassert>.
_static_assert_ - во время компиляции. (Поскольку static_assert не обрабатывается во время компиляции, то стейтменты static_assert могут быть размещены в любом месте кода (даже в глобальном пространстве))
```cpp
static_assert(sizeof(long) == 8, "long must be 8 bytes"); // тут будет ошибка
static_assert(sizeof(int) == 4, "int must be 4 bytes");
```
_initializer_list_ - список инициализации. Вы должны указать в угловых скобках, какой тип данных будете использовать
Имеется функция size(), которая возвращает количество элементов списка.
##### Пример
```cpp
#include <initializer_list>
class ArrayInt {
///
ArrayInt(const std::initializer_list<int> &list) :
    ArrayInt(list.size()) // позволяем инициализацию ArrayInt через список инициализации
{
    // Инициализация нашего начального массива значениями из списка инициализации
    int count = 0;
    for (auto &element : list) {
        m_data[count] = element;
	++count;
    }
}
///
int main()
{
    ArrayInt array { 7, 6, 5, 4, 3, 2, 1 }; // список инициализации
    for (int count = 0; count < array.getLength(); ++count)
	std::cout << array[count] << ' ';

    return 0;
}
```
 _default_ - суть спецификатора заключается в том, что пользователь может указать компилятору реализовать ту или иную функцию-член класса по-умолчанию.(применим только к конструкторам (по умолчанию, копирования, перемещения), деструктору и оператору присваивания/перемещения)
##### Пример
```cpp
class Foo
{
public:
    Foo() = default; //конструктор по умолчанию
    Foo(const Foo&) = default; //конструктор копирования
    Foo(Foo&&) = default; //конструктор перемещения
    ~Foo() = default; //деструктор
    Foo& operator=(Foo&&) = default; //оператор присваивания перемещением
    Foo& operator=(const Foo&) = default; //оператор присваивания копированием
    Foo(int x) {/* ... */} //конструктор с 1 параметром не может быть default
};
```
_final_ - С++11 позволяет запрещать в классах-наследниках переопределение определенных методов. Достигается это за счет применения спецификатора final рядом с сигнатурой метода. Можно даже запретить наследование определенного класса.
##### Примеры
```cpp
class Base
{
public:
    virtual void doSomething(int x) final;
};
class Derived : public Base
{
public:
    virtual void doSomething(int x); // ошибка!
};

```
```cpp
class Base final
{
public:
    virtual void doSomething(int x) final;
};
class Derived : public Base // ошибка
{
public:
    virtual void doSomething(int x);
};
```
_override_ - если метод не переопределяет виртуальную функцию родительского класса, то кимпилятор выдаст
ошибку.
##### Пример
```cpp
class Base
{
public:
    virtual void doSomething(int x);
};
// ...
class Derived : public Base
{
public:
    virtual void doSomething(int x) override; //не ошибка
    virtual void doSomething(long x) override; //ошибка
};
```
_using_ - используется для создания псевдонимов типа данных.
##### Примеры
```cpp
using std::cout; //объявление сообщает компилятору, что cout следует обрабатывать как std::cout
using iterator = typename std::vector<value_type>::iterator;
using namespace std; // использование пространства имен std
```
#### 11. Современный С++: std::optional, std::variant, std::any, std::string_view. Примеры использования
---
- Класс ```std::optional``` управляет опциональным значением, т. е. значением, которое может присутствовать или отсутствовать.
```cpp
std::optional<int> TryParseNumber(const std::string& str);

auto num = TryParseNumber("123");
if (num) {
  std::cout << num.value(); // или *num;
}
std::cout << num.value_or(0);

auto num = TryParseNumber("Not number");
if (num) {
  std::cout << num.value(); // или *num;
}
std::cout << num.value_or(0);
```
- Класс std::variant представляет собой типобезопасное объединение (union).
```cpp
std::variant<int, float> v;
v = 12
int a = std::get<int>(v);
int b = std::get<0>(v);

try {
    std::get<float>(v);
}
catch (const std::bad_variant_access&) {}
```

- Класс ```std::any``` – типобезопасносный контейнер для одиночного значения любого типа.
```cpp
std::any value;

value = 1;
value = std::string("Something");
value = Student{"Ivanov", "BMSTU", 2019};
std::string name = std::any_cast<Student>(value).Name;
```

```std::string_view``` - это класс, не владеющий строкой, но хранящий указатель на начало строки и её размер. Таким образом мы не владеем строкой а имеем "право просмтора"
```cpp
// C++11
#include <string>
void get_vendor_from_id(const std::string& id) { // аллоцирует память, если большой массив символов передан на вход вместо std::string
    std::cout <<
        id.substr(0, id.find_last_of(':')); // аллоцирует память при создании больших подстрок
}
```
```cpp
// C++17
#include <string_view>
void get_vendor_from_id(std::string_view id) { // не аллоцирует память, работает с `const char*`, `char*`, `const std::string&` и т.д.
    std::cout <<
        id.substr(0, id.find_last_of(':')); // не аллоцирует память для подстрок
}
```

#### 12. Лямбда-функции, функторы, указатели на функции, std::functional. Примеры использования std::functional. Примеры использования лямбда-функций.
---
_Лямбда-выражениями_ называются безымянные локальные функции, которые можно создавать прямо внутри какого-либо выражения.(лямбда-выражения в C++ — это краткая форма записи анонимных функторов.) По умолчанию лямба-функции возвращают void, однако при наличии одного return в лямбда-выражении, компилятор вычисляет тип возвращаемого значения самостоятельно. Если же в лямбда-выражении присутствует if или switch (или другие сложные конструкции) то надо указывать возвращаемый тип самостоятельно ```[] (int _n) -> double```

_Захват переменных из внешнего контекста_ - в лямбда-функции так же можно передавать переменные (список захвата), но при попытке изменить захваченные переменные получим ошибку (так как по умолчанию генерируемый operator()() объявлен как const), чтобы это обойти используем ключевое слово mutable. Так же можно передавать параметры по ссылке и использовать "режими захвата" ```[=] - по значению, [&] - по ссылке``` тогда все переменные используемые в лямбда-функции захватываются по умолчанию.


_Функторы_ — это прежде всего классы с перегруженной операцией (), а потом любые объекты, которые умеют вести себя как функции: это указатели на функции, лямбда-функции и имена функций, но сами функции и ссылки на функции функторами не являются, потому что они в терминах С++ не объекты.

_Указатель на функцию_ -  по сути указатель на функцию содержит адрес первого байта в памяти, по которому располагается выполняемый код функции. (имя так же является указателем на функцию).


_std::functional_ — библиотека, предоставляющая множество стандартных функторов (i.e. std::hash, etc)

_std::function<[function_type]>_ — полиморфная обёртка для функций, функторов, лямбда-выражений, функций-членов класса, привязки выражений (std::bind) и других вызываемых сущностей

```cpp
#include <functional>
#include <iostream>

struct Foo {
    Foo(int num) : num_(num) {}
    void print_add(int i) const { std::cout << num_+i << '\n'; }
    int num_;
};

void print_num(int i)
{
    std::cout << i << '\n';
}

int main()
{
    // store a free function
    std::function<void(int)> f_display = print_num;
    f_display(-9);

    // store a lambda
    std::function<void()> f_display_42 = []() { print_num(42); };
    f_display_42();

    // store the result of a call to std::bind
    std::function<void()> f_display_31337 = std::bind(print_num, 31337);
    f_display_31337();

    // store a call to a member function
    std::function<void(const Foo&, int)> f_add_display = &Foo::print_add;
    Foo foo(314159);
    f_add_display(foo, 1);
}
```

#### 13. R-value ссылки. Семантика перемещения. std::move, std::forward. Пример.
---
В С++ все переменные являются l-values(значение, которое имеет свой адрес памяти). Находятся в левой стороне от операции присваивания. r-values - это значение, которое не имеет постоянного адреса в памяти.
##### Пример
```cpp
int a;
а  = 5 ;
а = а + 2; //слева а - l-values, а справа r-values
```
Rvalue ссылки - ссылки, которые инициализируются только значениями r-values (создается с ипользованием &&). Они позволяют компилятору определить, когда необходимо использовать перемещение, вместо копирования. Основное отличие rvalue от lvalue в том, что объекты rvalue могут быть перемещены, тогда как объекты lvalue всегда копируются.
##### Плюсы:
- они увеличивают продолжительность жизни объекта, которым инициализируются, до продолжительности жизни ссылки r-values (ссылки l-values на константные объекты также могут это сделать)
- неконстантные ссылки r-values позволяют нам изменять значения r-values, на которые указывают ссылки r-values.
```cpp
int x = 7;
int &l = x; //l-values ссылка
int &&r = x; //r-values ссылка
```
Чаще всего r-values ссылки используют как параметры функции. Это наиболее полезно при перегрузке функций,
когда вы хотите, чтобы выполение функции отличалось в зависимости от аргументов.
Вы не должны возвращать ссылку r-values из функции, как и l-values. В большинстве случаев вы будете вовзращать висячую ссылку
(указывающую на удаленную память), а объект, на который будет ссылаться ссылка - выйдет
из области видимости в конце функции.
##### Пример
```cpp
#include <iostream>

void fun (const int &l)
{
    std::cout << "l-values reference";
}

void fun (int &&l)
{
    std::cout << "r-values reference";
}
int main()
{
    int x = 7;

    fun(x); //аргумент l-values
    fun(4); //аргумент r-values
}
```
_Cемантика перемещения_ означает, что класс, вместо копирования, передает право собственности на объект.

```std::move()``` — это стандартная библиотечная функция, которая конвертирует передаваемый аргумент в r-value. Мы можем передать l-value в std::move(), и std::move() вернёт нам ссылку r-value.
##### Пример
```cpp
#include <iostream>
#include <string>
#include <utility>
#include <vector>

int main()
{
	std::vector<std::string> v;
	std::string str = "Bye";

	std::cout << "Copying str\n";
	v.push_back(str); // вызывает версию l-value метода push_back, которая копирует str в элемент массива

	std::cout << "str: " << str << '\n'; //Bye
	std::cout << "vector: " << v[0] << '\n'; // Bye

	std::cout << "\nMoving str\n";

	v.push_back(std::move(str)); // вызывает версию r-value метода push_back, которая перемещает str в элемент массива

	std::cout << "str: " << str << '\n'; // ничего
	std::cout << "vector: " << v[0] << ' ' << v[1] << '\n';  //Bye Bye

	return 0;
}
```

```std::forward``` представляет собой условное приведение (в отличии от ```std::move```), эта функция выполняет приведение к rvalue только тогда, когда ее аргумент инициализирован rvalue, иначе
возвращает lvalue без изменения ее типа.

###### Пример
```cpp
#include <utility>      // std::forward
#include <iostream>     // std::cout

// function with lvalue and rvalue reference overloads:
void overloaded (const int& x) {std::cout << "[lvalue]\n";}
void overloaded (int&& x) {std::cout << "[rvalue]\n";}

// function template taking rvalue reference to deduced type:
template <class T> void fn (T&& x) {
  overloaded (x);                   // always an lvalue
  overloaded (std::forward<T>(x));  // rvalue if argument is rvalue
}

int main () {
  int a;
  std::cout << "calling fn with lvalue: ";
  fn (a);

  std::cout << "calling fn with rvalue: ";
  fn (0);

  return 0;
}
```

#### 14. Обработка ошибок с использованием механизма обработки исключений. RAII. Примеры классов, использующих RAII. Ключевое слово noexcept.
---
_throw_ генерирует исключение, затем в блок после ключевого слова _try_ помещается код, который потенциально может сгенерировать исключение, после ключевого слова _catch_ в скобках идет параметр, который передает информацию об исключении. Затем в блоке производится собственно обработка исключения.

Важно:
- при выбрасывании исключения (throw), точка выполнения программы немедленно переходит к ближайшему блоку try. Затем в блок catch, который прикреплен к этому try и обрабатывает этот тип исключения.
- если нет подходящего блока catch, то переходит к следующему try, если же вообще не будет найдено подходящее, то программа закончится с ошибкой исключения.
- компилятор не выполняет неявные преобразования при сопоставлении исключений с блоками catch. Исключение типа char не будет обрабатываться блоком catch типа int и так далее.

##### Пример
```cpp
#include <iostream>

int main()
{
    try{

    throw 4.2; //исключение типа double
    std::cout << "This never prints";
    }

    catch(double a)
    {
        std::cerr << a;
    }
}
```

- _Resource Acquisition Is Initialization_ - идиома объектно-ориентированного программирования, смысл которой заключается в том, что получение некоторого ресурса неразрывно совмещается с инициализацией объекта, а освобождение — с уничтожением. (Другими словами, выделяем память (или любой другой ресурс) в конструкторе некого объекта, а освобождаем - в деструкторе.)
```cpp
class Massiv
{

private:
    int *m_array;

public:
    Massiv(int length)
    {
    assert (length > 0)

    m_array = new int[length];
    }

    ~Massiv()
    {
    delete[] m_array;
    }
};
```
_Внимание!_ если вы используете функцию exit(), то ваша программа завершится, и никакие деструкторы
не будут вызваны.

_noexcept_ - спецификатор времени компиляции, которой говорит компилятору о том, что функция не будет выбрасывать исключения.
##### Плюсы
- оптимизаторам не надо поддерживать стек в сворачиваемом состоянии
- оптимизаторам не нужно гарантировать, что объекты в такой функции будут уничтожены в порядке, обратном созданию, если вдруг такую функцию покинет исключени.
##### Пример
```cpp
void f() noexcept;  //наиболее оптимизируемая
void f() throw();  //менее оптимизируемая
void f() ;  //менее оптимизируемая
```
#### 15. RAII. «Умные» указатели. std::shared_ptr. Примеры.
---
_Smart pointer_ — это объект, работать с которым можно как с обычным указателем, но при этом, в отличии от последнего, он предоставляет некоторый дополнительный функционал (например, автоматическое освобождение закрепленной за указателем области памяти).

Умные указатели призваны для борьбы с утечками памяти, которые сложно избежать в больших проектах. Они особенно удобны в местах, где возникают исключения, так как при последних происходит процесс раскрутки стека и уничтожаются локальные объекты. В случае обычного указателя — уничтожится переменная-указатель, при этом ресурс останется не освобожденным. В случае умного указателя — вызовется деструктор, который и освободит выделенный ресурс.
Одним из умных указателей является _shared_ptr_ (указатель на объект, которым владеет
сразу несколько объектов). Он реализует подсчет ссылок на ресурс. Ресурс освободится тогда,
когда счетчик ссылок на него будет равным 0. То есть система реализует одно из основных
правил сборщика мусора. Указатель можно как перемещать, так и копировать. Число существующих указателей отслеживается при помощи счетчика ссылок.
shared_ptr использует внутри два указателя. Один указывает на передаваемый ресурс, а второй указывает на «блок управления» — динамически выделенный объект, который отслеживает кучу разных вещей, включая и то, сколько std::shared_ptr одновременно указывают на каждый полученный ресурс. При создании std::shared_ptr с помощью конструктора std::shared_ptr, память для полученного ресурса и блока управления (которого также создаёт конструктор) выделяется отдельно. Однако в std::make_shared() это оптимизировано в единое выделение памяти, что, соответственно, повышает производительность.

При помощи этого указателя можно создавать циклические ссылки: есть два объекта. ПЕрвый ссылается
при помощи shared_ptr на второй, а второй на первый. Счетчики никогда не обнулятся, и объекты никогда
не будут уничтожены.
##### Создание
```cpp
#include <memory>

std::shared_ptr<int> x_ptr (new int (45)); // 1 вариант
auto ptr = std::make_shared<int>();  //проще, безопаснее и производительнее
```

##### Пример
```cpp

#include <iostream>
#include <memory> // для std::shared_ptr

class Item
{
public:
	Item() { std::cout << "Item acquired\n"; }
	~Item() { std::cout << "Item destroyed\n"; }
};

int main()
{
	// Выделяем Item и передаём его в std::shared_ptr
	Item *item = new Item;
	std::shared_ptr<Item> ptr1(item);
	//auto ptr1 = std::make_shared<Item>();
	{
		std::shared_ptr<Item> ptr2(ptr1); // используем оператор присваивания копированием для создания второго std::shared_ptr из ptr1, указывающего на тот же Item
        //нельзя использовать std::shared_ptr<Item> ptr2(item);
        //auto ptr2 = ptr1; используем семантику копирования
		std::cout << "Killing one shared pointer\n";
	} // ptr2 выходит из области видимости здесь, но больше ничего не происходит

	std::cout << "Killing another shared pointer\n";

	return 0;
} // ptr1 выходит из области видимости здесь и выделенный Item уничтожается также здесь
```
Разница здесь в том, что мы создали два отдельных, независимых друг от друга, умных указателя std::shared_ptr. Как следствие, хотя они оба указывают на один и тот же Item, они не знают о существовании друг друга. Когда ptr2 выходит из области видимости, он думает, что является единственным владельцем Item-а, поэтому уничтожает его. Когда позже ptr1 выходит из области видимости, он думает так же и пытается снова удалить (уже удалённый) Item.

##### Некоторые функции

- get (возвращает указатель на управляемый объект)

```cpp
#include <iostream>
#include <memory>

int main () {
  int* p = new int (10);
  std::shared_ptr<int> a (p);

  if (a.get()==p)
    std::cout << "a and p point to the same location\n";

  // three ways of accessing the same address:
  std::cout << *a.get() << "\n";
  std::cout << *a << "\n";
  std::cout << *p << "\n";

  return 0;
}
```

- use_count (возвращает количество объектов shared_ptr, которые ссылаются на тот же управляемый
объект)

```cpp
#include <memory>
#include <iostream>

void fun(std::shared_ptr<int> sp)
{
    std::cout << "fun: sp.use_count() == " << sp.use_count() << std::endl; // 2
}

int main()
{
    std::shared_ptr<int> sp1 {std::make_shared<int>(5)};
    std::cout << "sp1.use_count() == " << sp1.use_count() << std::endl; // 1

    fun(sp1);
}
```

- swap (обмен содержимым)

```cpp
// shared_ptr::swap example
#include <iostream>
#include <memory>

int main () {
  std::shared_ptr<int> foo (new int(10));
  std::shared_ptr<int> bar (new int(20));

  foo.swap(bar);

  std::cout << "*foo: " << *foo << '\n'; //20
  std::cout << "*bar: " << *bar << '\n'; //10

  return 0;
}
```
- reset (заменяет объект, которым владеет)
```cpp
#include <iostream>
#include <memory>

int main () {
  std::shared_ptr<int> sp;  // empty

  sp.reset (new int);       // takes ownership of pointer
  *sp=10;
  std::cout << *sp << '\n';

  sp.reset (new int);       // deletes managed object, acquires new pointer
  *sp=20;
  std::cout << *sp << '\n';

  sp.reset();               // deletes managed object

  return 0;
}
```

_Shared и многопоточность_
Подсчет ссылок в shared_ptr построен с использованием атомарного счетчика (операция
называется атомарной, если она завершается в один шаг относительно других потоков, имеющихдоступ к этой памяти)
. ЕСли какой-то shared_ptr доступен разным потокам и может быть модифицирован, то
необходимо позаботиться о синхронизации доступа к этому экземпляру
shared_ptr.

#### 16. RAII. «Умные» указатели. std::unique_ptr. Примеры.
---
- Шаблонный класс unique_ptr представляет собой уникальный указатель на объект.Его нужно использовать для управления
 любым динамически выделенным объектом/ресурсом, но с условием, что unique_ptr полность владеет переданным
 ему объектом, а не делится владением еще с другими классами. Указатель нельзя копировать, но можно передавать владение им с помощью std::move. При уничтожении указателя автоматически вызывается деструктор объекта, на который он указывает.


##### Cоздание
```cpp
#include <memory>

std::unique_ptr<int> item(new int); // 1
auto f2 = std::make_unique<int>(new int); //std::make_unique() решает проблему безопасности использования исключений, которая может возникнуть в результате неопределённого порядка обработки аргументов функции
```
```cpp
some_function(std::unique_ptr<T>(new T), function_that_can_throw_exception());
```
Здесь компилятору предоставляется большая гибкость при обработке вызова функции. Он может сначала выделить новый T, затем вызвать function_that_can_throw_exception(), а затем уже создать std::unique_ptr, который управляет динамически выделенным T. Если function_that_can_throw_exception() выбросит исключение, то выделенный T не будет корректно удалён, поскольку умный указатель, который должен выполнить его удаление — не успеет создаться. Это приведёт к утечке памяти.

```cpp
#include <iostream>
#include <memory> // для std::unique_ptr

class Item
{
public:
	Item() { std::cout << "Item acquired\n"; }
	~Item() { std::cout << "Item destroyed\n"; }
};

int main()
{
	std::unique_ptr<Item> item1(new Item); // выделение Item
	std::unique_ptr<Item> item2; // присваивается значение nullptr

	// item2 = item1; // не скомпилируется: семантика копирования отключена
	item2 = std::move(item1); // item2 теперь владеет item1, а для item1 присваивается значение null

	return 0;
} // Item уничтожается здесь, когда item2 выходит из области видимости
```
Поскольку std::unique_ptr разработан с учётом семантики перемещения, то семантика копирования по умолчанию отключена. Если вы хотите передать содержимое, управляемое std::unique_ptr, то вы должны использовать семантику перемещения. В программе выше мы передаём содержимое std::unique_ptr с помощью std::move() (который конвертирует item1 в r-value, которое является триггером для выполнения семантики перемещения вместо семантики копирования).

std::unique_ptr имеет перегруженные операторы * и ->, которые используются для доступа к хранимым объектам. Оператор * возвращает ссылку на управляемый ресурс, а оператор -> возвращает указатель.
```cpp
#include <iostream>
#include <memory>

struct Foo {
    void bar() { std::cout << "Foo::bar\n"; }
};

void f(const Foo& foo)
{
    std::cout << "f(const Foo&)\n";
}

int main()
{
    std::unique_ptr<Foo> ptr(new Foo);

    ptr->bar();
    f(*ptr);
}  // Foo::bar   f(const Foo&)
```
##### Некоторые функции

- get (возвращает указатель на управляемый объект)
```cpp
#include <iostream>
#include <memory>

int main () {
                                           // foo   bar    p
                                           // ---   ---   ---
  std::unique_ptr<int> foo;                // null
  std::unique_ptr<int> bar;                // null  null
  int* p = nullptr;                        // null  null  null

  foo = std::unique_ptr<int>(new int(10)); // (10)  null  null
  bar = std::move(foo);                    // null  (10)  null
  p = bar.get();                           // null  (10)  (10)

  delete p;   // the program is now responsible of deleting the object pointed to by p
              // bar deletes its managed object automatically

  return 0;
}
```

- reset (заменяет управляемый объект)
```cpp
#include <iostream>
#include <memory>

int main () {
  std::unique_ptr<int> up;  // empty

  up.reset (new int);       // takes ownership of pointer
  *up=5;
  std::cout << *up << '\n'; // 5

  up.reset (new int);       // deletes managed object, acquires new pointer
  *up=10;
  std::cout << *up << '\n'; // 10

  up.reset();               // deletes managed object

  return 0;
}
```

- release (возвращает указатель на управляемый объект и освобождает собственнось)
```cpp
#include <iostream>
#include <memory>

int main () {
  std::unique_ptr<int> auto_pointer (new int);
  int * manual_pointer;

  *auto_pointer=10;

  manual_pointer = auto_pointer.release();
  // (auto_pointer is now empty)

  std::cout << "manual_pointer points to " << *manual_pointer << '\n';

  delete manual_pointer;

```

- swap (обменивает управляемые объекты)
```cpp
#include <iostream>
#include <memory>

int main () {
  std::unique_ptr<int> foo (new int(10));
  std::unique_ptr<int> bar (new int(20));

  foo.swap(bar);

  std::cout << "foo: " << *foo << '\n'; //20
  std::cout << "bar: " << *bar << '\n'; //10

  return 0;
}
```

##### Ошибки
- Во-первых, не позволяйте нескольким классам «владеть» одним и тем же ресурсом.

```cpp
Item *item = new Item;
std::unique_ptr<Item> item1(item);
std::unique_ptr<Item> item2(item);
```
Хотя это синтаксически допустимо, конечным результатом будет то, что и item1, и item2 попытаются удалить Item, что приведёт к неопределённому поведению/результатам.
- Во-вторых, не удаляйте выделенный ресурс вручную из-под std::unique_ptr
```cpp
Item *item = new Item;
std::unique_ptr<Item> item1(item);
delete item;
```
Если вы это сделаете, std::unique_ptr попытается удалить уже удалённый ресурс, что снова приведёт к неопределённому поведению/результатам.
Также возможно _передавать_ (использовать std::move()) и _возвращать_ (не должны возвращать std::unique_ptr по адресу (вообще) или по ссылке (если у вас нет на это веских причин) unique_ptr из функции

#### 17. RAII. «Умные» указатели. std::weak_ptr. Примеры.
---

Одной из проблем при работе является с ```std::shared_ptr``` является возможность создания циклической ссылки (например когда два объекта ссылаются друг на друга, таким образом счетчик не обнулится и не будет вызван деструктор утечки памяти).

Эту проблему можно решить при помощи использования ```std::weak_ptr``` — он может наблюдать и получать доступ к тому же объекту, на который указывает std::shared_ptr (или другой std::weak_ptr), но не считаться владельцем этого объекта.
##### Пример
```cpp
#include <iostream>
#include <memory> // для std::shared_ptr и std::weak_ptr
#include <string>

class Human
{
	std::string m_name;
	std::weak_ptr<Human> m_partner; // обратите внимание, здесь std::weak_ptr

public:

	Human(const std::string &name): m_name(name)
	{
		std::cout << m_name << " created\n";
	}
	~Human()
	{
		std::cout << m_name << " destroyed\n";
	}

	friend bool partnerUp(std::shared_ptr<Human> &h1, std::shared_ptr<Human> &h2)
	{
		if (!h1 || !h2)
			return false;

		h1->m_partner = h2;
		h2->m_partner = h1;

		std::cout << h1->m_name << " is now partnered with " << h2->m_name << "\n";

		return true;
	}
};

int main()
{
	auto anton = std::make_shared<Human>("Anton");
	auto ivan = std::make_shared<Human>("Ivan");

	partnerUp(anton, ivan);

	return 0;
}
```
Когда ivan выходит из области видимости, он видит, что нет другого std::shared_ptr, указывающего на Ivan-а (std::weak_ptr из Anton-а не считается). Поэтому он уничтожает Ivan-а. То же самое происходит и с Anton-ом.

Недостатком std::weak_ptr является то, что его нельзя использовать напрямую (нет оператора ->). Чтобы использовать std::weak_ptr, вы сначала должны конвертировать его в std::shared_ptr (с помощью метода lock()), а затем уже использовать std::shared_ptr.

##### Функции

- lock (создает shared_ptr, который управляет объектом, на который ссылается weak_ptr)
```cpp
#include <iostream>
#include <memory>

int main () {
  std::shared_ptr<int> sp1,sp2;
  std::weak_ptr<int> wp;
                                       // sharing group:
                                       // --------------
  sp1 = std::make_shared<int> (20);    // sp1
  wp = sp1;                            // sp1, wp

  sp2 = wp.lock();                     // sp1, wp, sp2
  sp1.reset();                         //      wp, sp2

  sp1 = wp.lock();                     // sp1, wp, sp2

  std::cout << "*sp1: " << *sp1 << '\n'; //20
  std::cout << "*sp2: " << *sp2 << '\n'; //20

  return 0;
}
```

- expired (проверяет, был ли удален объект, на который ссылается weak_ptr (true, если управляемый объект уже удалён, false — если остался в памяти.))
```cpp
#include <iostream>
#include <memory>

std::weak_ptr<int> gw;

void f()
{
    if (!gw.expired()) {
    std::cout << "gw is valid\n";
    }
    else {
        std::cout << "gw is expired\n";
    }
}

int main()
{
    {
        auto sp = std::make_shared<int>(42);
    gw = sp;

    f();
    }

    f();
}
```
- reset (прекращает владение управляемым объектом)
```cpp
#include <iostream>
#include <memory>

int main () {
  std::shared_ptr<int> sp (new int(10));

  std::weak_ptr<int> wp(sp);

  wp.reset();

  std::cout << "2. wp ";
   if (wp.expired()==false)
   std::cout << "is" << " expired\n";

  return 0;
}
```
#### 18. Сетевое взаимодействие. Berkley sockets. Основные функции для работы с сокетами
---

Взаимодействие в сети рассматривается на основе понятия сокетов, которые позволяют приложениям рассматривать сетевые подключения как файлы, и программа может читать из сокета или писать в сокет, как она делает это с файлом. Существуют два механизма, предназначенных для сетевого взаимодействия программ, - это сокеты датаграмм, которые используют
пользовательский датаграммный протокол (User Datagram Protocol)
(UDP) без установления соединения, и сокеты, используюющие Протокол управления передачей / Межсетевой протокол (Transmission Control Protocol/Internet Protocol) (TCP/IP), устанавливающий соединение.

Для работы с сетью традиционно используются сокеты.
Сокет – это абстракция, которая позволяет работать с сетевыми ресурсами, как с файлами. Мы можем писать и читать данные из сокета почти так же, как из обычного файла.

Функция socket - создает новый сокет с заданными параметрами.
```cpp
int socket(int domain, int type, int protocol);

int sock_udp = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
int sock_tcp = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
```

Функция bind - связывает сокет с конкретным адресом сетевого интерфейса.
```cpp
int bind(int sockfd,
         const struct sockaddr *addr,
         socklen_t addrlen);
```
Где `sockaddr` - семейство структур, описывающих адреса (`sockaddr_in` - для сетевого взаимодействияб `sockaddr_un` для межпроцессорного):
Структура `sockaddr_in`:
```cpp
struct sockaddr_in {
    short            sin_family;   // e.g. AF_INET
    unsigned short   sin_port;     // e.g. htons(3490)
    struct in_addr   sin_addr;     // see struct in_addr, below
    char             sin_zero[8];  // zero this if you want to
};

struct in_addr {
    unsigned long s_addr;  // load with inet_aton()
};
```

Функция listen - переводит сокет в пассивный режим.
```cpp
int listen(int sockfd, int backlog);
```
Функция listen принимает дескриптор слушающего сокета и размер очереди запросов. Когда клиент пытается соединиться с сервером, его запрос ставится в очередь, так как сервер может быть занят обработкой других запросов. Если очередь заполнена, все последующие запросы будут игнорироваться.

Функция accept ожидает клиентские соединения.
```cpp
int accept(int sockfd,
           struct sockaddr *addr,
           socklen_t *addrlen);

```
В качестве аргумента функции передается дескриптор слушающего сокета.
При успешной установке соединения, для него создается новый сокет. Функция accept возвращает дескриптор этого сокета.
Если произошла ошибка соединения, то возвращается значение INVALID_SOCKET.

В структуру, на которую ссылается addr, записывается адрес сокета клиента, который установил соединение с сервером.
В переменную, адресуемую указателем addrlen, записывается размер структуры.

#### 19. Сетевое взаимодействие. Сокеты. Библиотека boost asio.
---
Взаимодействие в сети рассматривается на основе понятия сокетов, которые позволяют приложениям рассматривать сетевые подключения как файлы, и программа может читать из сокета или писать в сокет, как она делает это с файлом. Существуют два механизма, предназначенных для сетевого взаи-
модействия программ, - это сокеты датаграмм, которые используют
пользовательский датаграммный протокол (User Datagram Protocol)
(UDP) без установления соединения, и сокеты, используюющие Протокол управления передачей / Межсетевой протокол (Transmission Control Protocol/Internet Protocol) (TCP/IP), устанавливающий соединение.

Boost.Asio - кросс-платформенная С++ библиотека для программирования сетевых приложений и других низкоуровневых программ ввода/вывода.

Example:
```cpp
// Initialization
boost::system::error_code error;

boost::asio::io_service ioService{};
boost::asio::ip::tcp::socket socket{ioService, error};

...
...

// Binding to port
boost::asio::ip::tcp::endpoint endPoint{boost::asio::ip::v_4(), port};

socket.bind(endPoint, error);

...
...

// Connecting to server
socket.connect(someEndPoint, error);

...
...

// Read-write
std::string request;
request.resize(SOCKET_INPUT_BUFFER_SIZE);

socket.read_some(boost::asio::buffer(request), error);
if (error) {
  BOOST_LOG_TRIVIAL(error) << "Error while reading from socket : " << error;
  return error;
}

std::string response = HandleRequest(request, error);
if (error) {
  BOOST_LOG_TRIVIAL(error) << "Error while handling request : " << error;
  return error;
}

socket.write_some(boost::asio::buffer(response), error);
if (error) {
  BOOST_LOG_TRIVIAL(error) << "Error while writing to socket : " << error;
  return error;
}
```

#### 20. Переключение контекста потоков. Класс std::thread. Ключевое слово thread_local. Примеры использования std::thread.
---
_Контекст потоков_

Чтобы операционная система поддерживала многозадачность, каждый выполняемый поток должен обладать своим контекстом исполнения. Этот контекст используется для хранения данных о текущем состоянии потока: значения регистров процессора, указателя на стек данных, указатель на текущую выполняемую команду. В системе количество потоков может превышать (а на самом деле, почти всегда превышает) число ядер. И чтобы задачи могли корректно исполняться применяться механизм переключения между ними.

- ОС передает поток на исполнение ядру процессора.
- Этот поток исполняется в течение некоторого временного интервала.
- После завершения этого интервала контекст ОС переключается на другой поток.

_Переключение контекста_

 - обновляется контекст текущего потока
 - из имеющихся потоков в ОС выбирается один, который будет исполняться на процессоре
 - загружается контекст выбранного потока

Класс std::thread  применяется  для  управления  потоком  выполнения. В нем имеются средства для запуска нового потока и ожидания завершения потока, а также для идентификации потоков. Также в класс включены другие функции для управления потоком выполнения

Создание объекта типа std::thread запускает новый поток. До вызова деструктора объекта типа std::thread необходимо вызвать или метод join(), или метод detach().

Вызов метода join приведет к ожиданию завершения потока. Это значит, что до тех пор пока поток не завершит своё выполнение, основной поток не будет выполнять код находящийся после вызова метода join(). Этот метод необходимо использовать, если основному потоку необходим и важен результат выполнения дочернего потока.
Например, когда необходимо дождаться загрузки данных для дальнейшей обработки этих данных.

- ```std::thread::detach```

Вызов функции detach оставляет поток работать в фоновом режиме. Это значит, что код находящийся после вызова метода detach() может выполняться пока выполняется запущенный поток. Этот метод необходимо использовать, если основному потоку не важен результат выполнения дочернего потока. Например, отправка пользовательской статистики.

Флаг  типа  thread_local  –  основная  причина,  по  которой  мы  не  можем  использовать  для  управления  потоком  просто  класс  std::thread;  память  для  него  нужно  выделить  таким  образом,  чтобы  к  ней имел доступ как экземпляр interruptible_thread, так и вновь запущенный  поток.  Для  этого  функцию,  переданную  конструктору,  можно  специальным  образом  обернуть  перед  тем,  как  передавать  конструктору std::thread. Как это делается, показано в следующем листинге.

```cpp
class interrupt_flag{
public:
    void  set();
    bool  is_set()  const;
};
thread_local interrupt_flag this_thread_interrupt_flag;
    interruptible_thread{
    std::thread  internal_thread;
    interrupt_flag*  flag;
public:
    template<typename  FunctionType>    interruptible_thread(FunctionType  f)  {
      std::promise<interrupt_flag*> p;
      internal_thread=std::thread([f,&p]{
         p.set_value(&this_thread_interrupt_flag);
         f();
      });
      flag=p.get_future().get();
       }
      void  interrupt()  {
        if(flag)   {
          flag->set();
      }
  }
};

```

Пример использования std::thread:
```cpp
void hello() {
  std::cout << "Hello, World!";
}

int main() {
  std::thread th(hello);
  th.join();
}

```

#### 21 Синхронизация потоков. Состояние гонок. Классы std::mutex, std::lock_guard, std::unique_lock. Функция std::lock. Примеры использования мьютексов.
---
_Гонка за данными_

В программировании под состоянием “гонки” понимается любая ситуация, исход которой зависит от относительного порядка выполнения операций в более чем в одном потоке.

_Устранение гонок_

Гонки приводят к ошибкам в случае, если они (гонки) приводят к нарушению инвариантов.
Инвариант - утверждение о структуре данных, которое всегда должно быть истинным.


Чтобы избежать проблем с синхронизацией потоков можно использовать структуры данных без блокировки.
Т.е. изменить дизайн структуры данных и её инварианты так, чтобы модификация представляла собой последовательность неделимых изменений, каждое из которых сохраняет инварианты. Такой подход называется программированием без блокировок.

Взаимоисключающая блокировка - простейший сбособ защиты разделяемых данных.
Мьютексы - наиболее общий механизм защиты данных в С++.

```cpp
class mutex {
public:
    void lock();
    bool try_lock();
    void unlock();
    native_handle_type native_handle();
};

std::cout paper;
std::mutex mutex;

void WriteVerse() {
  mutex.lock();
  for (auto str : CreateVerse()) {
    paper << str;
  }
  mutex.unlock();
}

std::jthread Pushkin(WriteVerse);
std::jthread Lermontov(WriteVerse);
std::jthread Fet(WriteVerse);
```

Необходимо освобождать мьютекс на каждом пути выхода из функции, в том числе и при исключениях. Чтобы упростить эти операции, был создан std::lock_guard

```cpp
template <typename mutex_type>
struct lock_guard {
  explicit lock_guard( mutex_type& m );
  lock_guard( mutex_type& m, std::adopt_lock_t t );
  lock_guard( const lock_guard& ) = delete;
  // ...
};
void WriteVerse() {
  std::lock_guard<std::mutex> lk(mutex);
  for (auto str : CreateVerse()) {
    paper << str;
  }
}
```
Класс std::unique_lock обладает большей гибкостью, чем std::lock_guard.

- std::unique_lock реализует семантику перемещения
- std::unique_lock позволяет управлять ассоциированным с ним мьютексом (есть методы lock, try_lock, unlock)

Конструкторы std::unique_lock:
- конструктор с defer_lock_t не захватывает мьютекс
- конструктор с try_to_lock_t пытается захватить мьютекс с помощью функции try_lock()
- конструктор с adopt_lock_t используется в случае, если мьютекс уже захвачен текущим потоком

В С++ есть функция std::lock, которая захватывает сразу несколько мьютексов.
Если std::lock успешно захватила первый мьютекс, но во время попытки захвата второго мьютекса произошло исключение, то первый мьютекс освобождается.

#### 22. Синхронизация потоков. Состояние гонок. Классы std::recursive_mutex, boost::shared_mutex, std::unique_lock. Функция std::lock. Пример использования std::unique_lock.
---
_Гонка за данными_

В программировании под состоянием “гонки” понимается любая ситуация, исход которой зависит от относительного порядка выполнения операций в более чем в одном потоке.

_Устранение гонок_

Гонки приводят к ошибкам в случае, если они (гонки) приводят к нарушению инвариантов.
Инвариант - утверждение о структуре данных, которое всегда должно быть истинным.

Чтобы избежать проблем с синхронизацией потоков можно использовать структуры данных без блокировки.
Т.е. изменить дизайн структуры данных и её инварианты так, чтобы модификация представляла собой последовательность неделимых изменений, каждое из которых сохраняет инварианты. Такой подход называется программированием без блокировок.

Взаимоисключающая блокировка - простейший сбособ защиты разделяемых данных.

Мьютексы - наиболее общий механизм защиты данных в С++.

```
class mutex {
public:
    void lock();
    bool try_lock();
    void unlock();
    native_handle_type native_handle();
};

std::cout paper;
std::mutex mutex;

void WriteVerse() {
  mutex.lock();
  for (auto str : CreateVerse()) {
    paper << str;
  }
  mutex.unlock();
}

std::jthread Pushkin(WriteVerse);
std::jthread Lermontov(WriteVerse);
std::jthread Fet(WriteVerse);
```

Если несколько потоков только считывают данные и не модифицируют их, то гонок за данными не возникает.Поэтому иногда разумно предоставлять доступ для чтения к разделяемым данным нескольким потоком одновременно. Если же какой-то поток пытается модифицировать данные, то ему следует предоставлять монопольный доступ. Для такой ситуации существует класс shared_mutex.

В С++ есть функция std::lock, которая захватывает сразу несколько мьютексов.
Если std::lock успешно захватила первый мьютекс, но во время попытки захвата второго мьютекса произошло исключение, то первый мьютекс освобождается.

Иногда текущему потоку требуется оповестить о совершенном событии другие потоки, которым для своей работы необходимо знать об этом событии. Один из механизмов, который можно использовать для реализации такого поведения, – это std::future и std::promise. Однако, такой механизм может передавать сигнал от одного потока другому только один раз.

Класс std::recursive_mutex предоставляет базовые средства вза-имного  исключения  и  синхронизации  потоков,  применяемые  для  защиты  разделяемых  данных.  Перед  тем  как  обращаться  к  данным,  защищаемым мьютексом, этот мьютекс необходимо захватить (или заблокировать),  вызвав  функцию  lock()  или  try_lock().  В  любой  момент времени удерживать мьютекс может только один поток; если другой поток попытается захватить тот же мьютекс, то функция try_lock() вернет ошибку, а функция lock() приостановит выполнение потока.  Закончив  операции  над  разделяемыми  данными,  поток  дол-жен  вызвать  функцию  unlock(),  чтобы  освободить  мьютекс  и  дать  другим потокам возможность захватить его.Этот мьютекс называется рекурсивным, потому что поток, удержива-ющий мьютекс типа std::recursive_mutex, может снова обратиться к функции lock() или try_lock(), что приведет к увеличению счет-чика  захватов.  Никакой  другой  поток  не  сможет  захватить  этот  мью-текс,  пока  владеющий  им  поток  не  вызовет  функцию  unlock  столько  раз, сколько было успешных вызовов lock() или try_lock().

Пример с std::unique_lock
```cpp
struct Box {
    explicit Box(int num) : num_things{num} {}

    int num_things;
    std::mutex m;
};

void transfer(Box &from, Box &to, int num)
{
    // don't actually take the locks yet
    std::unique_lock<std::mutex> lock1(from.m, std::defer_lock);
    std::unique_lock<std::mutex> lock2(to.m, std::defer_lock);

    // lock both unique_locks without deadlock
    std::lock(lock1, lock2);

    from.num_things -= num;
    to.num_things += num;

    // 'from.m' and 'to.m' mutexes unlocked in 'unique_lock' dtors
}

int main()
{
    Box acc1(100);
    Box acc2(50);

    std::thread t1(transfer, std::ref(acc1), std::ref(acc2), 10);
    std::thread t2(transfer, std::ref(acc2), std::ref(acc1), 5);

    t1.join();
    t2.join();
}

```

#### 23. Класс std::condition_variable. Потокобезопасные структуры данных с блокировками.
---
_Conditional Variable_

Для синхронизации логических зависимостей между потоками, которыми можно обмениваться многократно, можно использовать условные переменные. Условные переменные предоставляют простой механизм ожидания события, возникающего в другом потоке.

Проектирование  параллельных  структур  данных  с  блокировками  сводится  к  тому,  чтобы  захватить  нужный  мьютекс  при  доступе  к  данным и удерживать его минимально возможное время.

```cpp
struct empty_stack: std::exception {
    const char* what() const throw();
};
template<typename T>class threadsafe_stack{
private:
    std::stack<T>  data;
    mutable  std::mutex  m;
public:    threadsafe_stack(){}
    threadsafe_stack(const  threadsafe_stack&  other)  {
      std::lock_guard<std::mutex>  lock(other.m);
      data=other.data;
    }
    threadsafe_stack& operator=(const threadsafe_stack&) = delete;
    void  push(T  new_value)  {
      std::lock_guard<std::mutex>  lock(m);
      data.push(std::move(new_value));
      }
     std::shared_ptr<T>  pop()  {
      std::lock_guard<std::mutex>  lock(m);
      if(data.empty()) throw empty_stack();
      std::shared_ptr<T>  const  res(
          std::make_shared<T>(std::move(data.top())));
      data.pop();
      return  res;
      }

      void  pop(T&  value)  {
      std::lock_guard<std::mutex>  lock(m);
      if(data.empty())  throw  empty_stack();
      value=std::move(data.top());
      data.pop();
      }
      bool  empty()  const  {
      std::lock_guard<std::mutex>  lock(m);
      return  data.empty();
  }};
}

```

#### 24. Синхронизация потоков. Пул потоков. Класс std::condition_variable. Примеры работы с std::condition_variable.
---
  Чтобы избежать проблем с синхронизацией потоков можно использовать структуры данных без блокировки. Т.е. изменить дизайн структуры данных и её инварианты так, чтобы модификация представляла собой последовательность неделимых изменений, каждое из которых сохраняет инварианты. Такой подход называется программированием без блокировок.

Взаимоисключающая блокировка - простейший сбособ защиты разделяемых данных.

Мьютексы - наиболее общий механизм защиты данных в С++.

```
class mutex {
public:
    void lock();
    bool try_lock();
    void unlock();
    native_handle_type native_handle();
};

std::cout paper;
std::mutex mutex;

void WriteVerse() {
  mutex.lock();
  for (auto str : CreateVerse()) {
    paper << str;
  }
  mutex.unlock();
}

std::jthread Pushkin(WriteVerse);
std::jthread Lermontov(WriteVerse);
std::jthread Fet(WriteVerse);

```

Если несколько потоков только считывают данные и не модифицируют их, то гонок за данными не возникает. Поэтому иногда разумно предоставлять доступ для чтения к разделяемым данным нескольким потоком одновременно. Если же какой-то поток пытается модифицировать данные, то ему следует предоставлять монопольный доступ. Для такой ситуации существует класс shared_mutex.

Для такого поведения в С++ есть функция std::lock, которая захватывает сразу несколько мьютексов.
Если std::lock успешно захватила первый мьютекс, но во время попытки захвата второго мьютекса произошло исключение, то первый мьютекс освобождается.

Иногда текущему потоку требуется оповестить о совершенном событии другие потоки, которым для своей работы необходимо знать об этом событии. Один из механизмов, который можно использовать для реализации такого поведения, – это std::future и std::promise.

Однако, такой механизм позволяет может передавать сигнал от одного потока другому только один раз.

_Conditional Variable_

Для синхронизации логических зависимостей между потоками, которыми можно обмениваться многократно, можно использовать условные переменные. Условные переменные предоставляют простой механизм ожидания события, возникающего в другом потоке. Их работу удобно рассмотреть на примере шаблона паралелльного программирования Producer-Consumer.

Пример использования condition variables:
```
std::mutex m;
std::queue<std::string> queue;
std::condition_variable cv;

void Producer() {
  std::lock_guard<std::mutex> lk(m);
  queue.push(ReadMessageFromNetwork());
  cv.notify_one();
}

void Consumer() {
  std::unique_lock<std::mutex> lk(m);

  while(queue.empty()) {
    cv.wait(lk);
  }

  // Используем очередь.
  lk.unlock();
  // Продолжаем выполнения потока.
}
```

_Пул потоков_

В простейшем случае пул состоит из  фиксированного числа рабочих потоков  (обычно  равного  значению,  которое  возвращает  функция std::thread::hardware_concurrency()).  Когда  у  программы  по-является  какая-то  работа,  она  вызывает  функцию,  которая  помеща-ет  эту  работу  в  очередь.  Рабочий  поток  забирает  работу  из  очереди,  выполняет  указанную  в  ней  задачу,  после  чего  проверяет,  есть  ли  в  очереди другие работы.

#### 25. Управление потоками. Состояния гонок в интерфейсе структур данных. Класс std::future,функция std::async
---
Состояния гонок в интерфейсе стурктур данных - гонки, возникающие при обращении к объекту, в ходе которых нарушаются его инварианты. Инвариант - некое условие, выполнение которого необходимо для правильной работы струтктуры. К примеру поле size класса vector хранит количество элементов в массиве. Если это не так (допустим, произошла ошибка доступа к соотвествующему объекту и поле было изменено некорректно), то инвариант нарушен. Помимо этого Вильямс упоминает, что методы доступа и получения информации о структурах нельзя считать валидными, поскольку данные, полученные с помощью этих методов, были правильными лишь в момент их получения. То есть, после их получения и перед использованием данные могут быть изменены другим потоком.

```std::async``` - функция, позволяющая запустить выполнение операции в новом потоке. В отличие от ```std::thread```, для ```std::async``` существует способ получения возвращаемого функцией значения. async возвращает объект ```std::future```, потенциально содержащий результат выполнения операции (или исключение, в случае ошибки).
async имеет конструктор подобный ```std::thread```, так же принимает функцию и ее аргументы. Дополнительно первым аргументом может быть указано правило запуска потока - ```std::launch::async``` или ```std::launch::deferred```. В первом случае новый поток запустится асинхронно, во втором же случае новый поток создан не будет, а результат начнет вычисляться в текущем потоке по первому запросу. Если же указаны оба флага - поведение зависит от реализации, ни одного - аналогично.

```std::future``` - обертка над реазультатом асинхронной операции. Такой объект возвращает ```std::async```.
Присутствует метод get, позволяющий получить результат, но его вызов обязан быть однократным (в противном случае - неопределенное поведение). ```std::future``` имеет метод valid, позволяющий проверить был ли получен результат. Так же имеет фунции ожидания (wait, в частности), которые испольузуются методом get если результат еще не готов.

#### 26. Атомарные операции. Классы std::atomic, std::atomic_flag. Примеры работы с std::atomic
---
Под атомарными понимаются неделимые операции. Ни из одного потока в системе невозможно увидеть, что такая операция выполнена наполовину – она либо выполнена целиком, либо не выполнена вовсе. Если операция загрузки, которая читает значение объекта, атомарна, и все операции модификации этого объекта также атомарны, то в результате загрузки будет получено либо начальное значение объекта, либо значение, сохраненное в нем после одной из модификаций.

Каждая специализация шаблона ```std::atomic``` определяет атомарный тип. Только объекты атомарных С++ типов могут безопасно использоваться в нескольких потоках одновременно. Когда один поток сохраняет данные в объекте атомарного типа, а другой хочет их прочитать, поведение программы определено стандартом.

```cpp
Typedef имя		Full specialization
std::atomic_char 	std::atomic<char>
std::atomic_schar 	std::atomic<signed char>
std::atomic_uchar 	std::atomic<unsigned char>
std::atomic_short 	std::atomic<short>
std::atomic_ushort 	std::atomic<unsigned short>
std::atomic_int 	std::atomic<int>
std::atomic_uint 	std::atomic<unsigned int>
std::atomic_long 	std::atomic<long>

```

```std::atomic_flag``` - это по настоящему простой булевский флаг, а операции над этим типом обязаны быть свободными от блокировок, если имеется простой свободный от блокировок булевский флаг, то на его основе можно реализовать простую  блокировку и, значит, все остальные атомарные типы.

Объект типа ```std::atomic_flag``` должен быть инициализирован значением ```ATOMIC_FLAG_INIT```.

Пример использования ```std::atomic_flag```:
```
class spinlock_mutex {
  std::atomic_flag  flag;
public: spinlock_mutex(): flag(ATOMIC_FLAG_INIT)  {}
  void  lock() {
    while(flag.test_and_set(std::memory_order_acquire));
}
  void  unlock() {
    flag.clear(std::memory_order_release);
  }
};

```

#### 27. Шаблоны проектирования: фабричный метод. Пример реализации «простой фабрики» и «фабричного метода».
---
Для того, чтобы система оставалась независимой от различных типов объектов, паттерн Factory Method использует механизм полиморфизма - классы всех конечных типов наследуют от одного абстрактного базового класса, предназначенного для полиморфного использования. В этом базовом классе определяется единый интерфейс, через который пользователь будет оперировать объектами конечных типов.

Реализация:
```cpp
class Warrior
{
  public:
    virtual void info() = 0;
    virtual ~Warrior() {}
};

class Infantryman: public Warrior
{
  public:
    void info() {
      cout << "Infantryman" << endl;
    };
};

class Archer: public Warrior
{
  public:
    void info() {
      cout << "Archer" << endl;
    };
};

class Horseman: public Warrior
{
  public:
    void info() {
      cout << "Horseman" << endl;
    };
};


// Фабрики объектов
class Factory
{
  public:
    virtual Warrior* createWarrior() = 0;
    virtual ~Factory() {}
};

class InfantryFactory: public Factory
{
  public:
    Warrior* createWarrior() {
      return new Infantryman;
    }
};

class ArchersFactory: public Factory
{
  public:
    Warrior* createWarrior() {
      return new Archer;
    }
};

class CavalryFactory: public Factory
{
  public:
    Warrior* createWarrior() {
      return new Horseman;
    }
};


// Создание объектов при помощи фабрик объектов
int main()
{
    InfantryFactory* infantry_factory = new InfantryFactory;
    ArchersFactory*  archers_factory  = new ArchersFactory ;
    CavalryFactory*  cavalry_factory  = new CavalryFactory ;

    vector<Warrior*> v;
    v.push_back( infantry_factory->createWarrior());
    v.push_back( archers_factory->createWarrior());
    v.push_back( cavalry_factory->createWarrior());

    for(int i=0; i<v.size(); i++)
        v[i]->info();
    // ...
}

```

#### 28. Шаблоны проектирования: observer. Пример реализации «обозреватель».
---
_Наблюдатель (англ. Observer)_ — поведенческий шаблон проектирования. Также известен как «подчинённые» (Dependents). Реализует у класса механизм, который позволяет объекту этого класса получать оповещения об изменении состояния других объектов и тем самым наблюдать за ними

_Observer_ — поведенческий шаблон проектирования. Реализует у класса механизм, который позволяет объекту этого класса получать оповещения об изменении состояния других объектов и тем самым наблюдать за ними.

Реализация:
```cpp
class SupervisedString;
class IObserver
{
public:
    virtual void handleEvent(const SupervisedString&) = 0;
};

class SupervisedString // Observable class
{
    string _str;
    list<IObserver*> _observers;

    void _Notify()
    {
        for(auto& observer: _observers)
        {
            observer->handleEvent(*this);
        }
    }

public:
    void add(IObserver& ref)
    {
        _observers.push_back(&ref);
    }

    void remove(IObserver& ref)
    {
        _observers.remove(&ref);
    }

    const string& get() const
    {
        return _str;
    }

    void reset(string str)
    {
        _str = str;
        _Notify();
    }
};

class Reflector: public IObserver // Prints the observed string into cout
{
public:
    virtual void handleEvent(const SupervisedString& ref)
    {
        std::cout << ref.get() << std::endl;
    }
};

class Counter: public IObserver // Prints the length of observed string into cout
{
public:
  virtual void handleEvent(const SupervisedString& ref)
  {
      std::cout << "length = " << ref.get().length() << std::endl;
  }
};

int main()
{
    SupervisedString str;
    Reflector refl;
    Counter cnt;

    str.add(refl);
    str.reset("Hello, World!");
    std::cout << endl;

    str.remove(refl);
    str.add(cnt);
    str.reset("World, Hello!");
    std::cout << endl;

    return 0;
}
```

#### 29. Асинхронное программирование. Плюсы и минусы. Сопрограммы. Функции обратного вызова.
---
Функция std::async  позволяет  запустить  асинхронную  зада-чу,  результат  которой  прямо  сейчас  не  нужен.  Но  вместо  объекта  std::thread  она  возвращает  объект  std::future  ,  который  будет  содержать возвращенное значение, когда оно станет доступно. Когда программе понадобится значение, она вызовет функцию-член get()объекта-будущего, и тогда поток будет приостановлен до готовности будущего  результата,  после  чего  вернет  значение.

```cpp
#include <future>
#include <iostream>
int find_the_answer_to_ltuae();
void do_other_stuff();

int main() {
std::future<int> the_answer = std::async(find_the_answer_to_ltuae);
do_other_stuff();
std::cout << ”Ответ равен “ << the_answer.get() <<std::endl;
}

```

Шаблон std::async  позволяет  передать  функции  дополнительные  параметры,  точно  так  же,  как  std::thread.  Если  первым  аргументом  является  указатель  на  функцию-член,  то  второй  аргумент  должен  содержать  объект,  от  имени  которого  эта  функция-член  вы-зывается

```cpp
struct X {
  void foo(int,std::string const&);
  std::string bar(std::string const&);
};

X x;
auto f1=std::async(&X::foo,&x,42,”hello”);  // Вызывается p->foo(42,"hello"), где p=&x
auto f2 = std::async(&X::bar,x,”goodbye”); // Вызывается tmpx.bar("goodbye"), где tmpx – копия x

```

Также можно  задать  требуемый  режим исполнения в  дополнительном  параметре  std::async  перед  вызываемой  функцией.  Этот  параметр  имеет  тип  std::launch  и  может  принимать  сле-дующие значения: std::launch::deferred – отложить вызов функции до того момента, когда будет вызвана функция-член wait() или get() объекта-будущего; std::launch::async – запускать функцию в    отдельном    потоке;    std::launch::deferred | std::launch::async – оставить решение на усмотрение реализации.

Плюсы и минусы асинхронного подхода:
  1) Безусловный плюс — это производительность. Причем она не просто в разы выше, она выше на порядки!
  2) Минус — сложный и запутанный код, который к тому же еще и сложно отлаживать.

Сопрограммы
Сопрограммы (корутины, coroutine) - это потоки исполнения кода, которые организуются поверх аппаратных (системных) потоков.
Поток исполнения кода - это последовательность операций, которые выполняются друг за другом. В нужные моменты эта последовательность может быть приостановлена, и вместо нее может начать выполняться часть другой последовательности операций.

В отличие от системных потоков, которые переключаются системой в произвольные моменты времени (вытесняющая многозадачность), сопрограммы переключаются вручную, в местах, указанных программистом (кооперативная многозадачность).

Обозначим операции над сопрограммой следующим образом:
```cpp
handle = spawn(СП); - запуск сопрограммы,
yield; - приостановка текущей сопрограммы,
resume(handle); - возобновление сопрограммы.
```

Возьмем две сопрограммы:
```cpp
// СП1      |  // СП2
{           |  {
  f1();     |     g1();
  f2();     |     yield;
  yield;    |     g2();
  f3();     |     g3();
  f4();     |     yield;
  yield;    |     g4();
  f5();     |     g5();
}           |  }

```
Тогда, если на одном системном потоке запустить СП1, а затем СП2, то системный поток выполнит операции в следующем детерминированном порядке:

```cpp
// Системный поток  |  Выполняемый код
c1 = spawn(СП1);    |  f1();
                    |  f2();
c2 = spawn(СП2);    |       g1();
resume(c1);         |  f3();
                    |  f4();
resume(c2);         |       g2();
                    |       g3();
resume(c1);         |  f5();
resume(c2);         |       g4();
                    |       g5();

```

Функции обратного вызова

Функция обратного вызова в программировании — передача исполняемого кода в качестве одного из параметров другого кода. Обратный вызов позволяет в функции исполнять код, который задаётся в аргументах при её вызове.

```cpp
/* The calling function takes a single callback as a parameter. */
void PrintTwoNumbers(int (*numberSource)(void)) {
    int val1 = numberSource();
    int val2 = numberSource();
    printf("%d and %d\n", val1, val2);
}

/* A possible callback */
int overNineThousand(void) {
    return (rand()%1000) + 9001;
}

/* Another possible callback. */
int meaningOfLife(void) {
    return 42;
}

/* Here we call PrintTwoNumbers() with three different callbacks. */
int main(void) {
    PrintTwoNumbers(&rand);
    PrintTwoNumbers(&overNineThousand);
    PrintTwoNumbers(&meaningOfLife);
    return 0;
}

```

#### 30. Атомарные операции. Классы std::atomic. Структуры данных без блокировок. Реализация lock-free stack
---
Операция в общей области памяти называется атомарной, если она завершается в один шаг относительно других потоков, имеющих доступ к этой памяти. Во время выполнения такой операции над переменной, ни один поток не может наблюдать изменение наполовину завершенным. Атомарная загрузка гарантирует, что переменная будет загружена целиком в один момент времени. Неатомарные операции не дают такой гарантии.

Каждая специализация шаблона ```std::atomic``` определяет атомарный тип. Только объекты атомарных С++ типов могут безопасно использоваться в нескольких потоках одновременно. Когда один поток сохраняет данные в объекте атомарного типа, а другой хочет их прочитать, поведение программы определено стандартом.

```cpp
Typedef имя		Full specialization
std::atomic_char 	std::atomic<char>
std::atomic_schar 	std::atomic<signed char>
std::atomic_uchar 	std::atomic<unsigned char>
std::atomic_short 	std::atomic<short>
std::atomic_ushort 	std::atomic<unsigned short>
std::atomic_int 	std::atomic<int>
std::atomic_uint 	std::atomic<unsigned int>
std::atomic_long 	std::atomic<long>
```

Структуры данных и алгоритмы, в которые блокирующие библиотечные  функции  не  используются,  называются  неблокирующими. Чтобы  структура  данных  считалась  свободной  от  блокировок,  она  должна быть открыта для одновременного доступа со стороны сразу нескольких  потоков.

```cpp
template<typename T>class lock_free_stack {
private:
    struct node;
    struct counted_node_ptr {
        int external_count;
        node*  ptr;
    };

    struct node {
        std::shared_ptr<T> data;
        std::atomic<int> internal_count;
        counted_node_ptr next;
        explicit node(T const& data_): data(std::make_shared<T>(data_)), internal_count(0) {}
    };

    std::atomic<counted_node_ptr> head;

    void increase_head_count(counted_node_ptr& old_counter) {
        counted_node_ptr new_counter;
        do {
            new_counter = old_counter;
            ++new_counter.external_count;
        } while(!head.compare_exchange_strong(old_counter, new_counter, std::memory_order_acquire, std::memory_order_relaxed));
        old_counter.external_count = new_counter.external_count;
    }

public:
    ~lock_free_stack() {
        while(pop());
    }

    void push(T const& data)  {
        counted_node_ptr new_node;
        new_node.ptr = new node(data);
        new_node.external_count = 1;
        new_node.ptr->next = head.load(std::memory_order_relaxed);
        while(!head.compare_exchange_weak(new_node.ptr->next, new_node, std::memory_order_release, std::memory_order_relaxed));
    }

    std::shared_ptr<T> pop() {
        // Загружаем атомарно значение головы стека
        counted_node_ptr old_head = head.load(std::memory_order_relaxed);
        for(;;) {
            // Увеличиваем счетчик внешних ссылок на head
            // Устанавливаются  все  поля структуры, чтобы быть уверенным, что другой поток не изменил в промежутке указатель.
            increase_head_count(old_head);
            node* const ptr = old_head.ptr;

            // Проверка на пустой стек
            if(!ptr) {
                return std::shared_ptr<T>();
            }

            // Мы можем попытаться исключить узел из списка, выполнив compare_exchange_strong() с головным узлом head
            if(head.compare_exchange_strong(old_head, ptr->next, std::memory_order_relaxed)) {
                std::shared_ptr<T> res;
                // Если compare_exchange_strong()  возвращает  true,  то  мы  при-няли  на  себя  владение  узлом
                // И  можем  с  помощью  функции  swap() вытащить  из  него  данные,  которые  впоследствии  вернем
                res.swap(ptr->data);
                // мы исключили узел из списка, вследствие чего значение счетчика уменьшилось на 1
                // и больше не обращаемся к узлу из данного потока, что дает уменьше-ние еще на 1
                int const count_increase = old_head.external_count - 2;
                // Затем можно прибавить внешний счетчик к внутреннему с помощью атомарной операции fetch_add
                // fetch_add возвращает значение атомарной переменной до вызова
                // Если теперь счетчик ссылок стал равен нулю, то предыдущее значение
                // (то, которое возвращает fetch_add) было противоположно только что прибавленному, и тогда узел можно удалять.
                if(ptr->internal_count.fetch_add(count_increase, std::memory_order_release) == -count_increase) {
                    delete ptr;
                }
                return res;
                // Если сравнение не прошло, значит head модифицировали => начинаем заново
            } else if(ptr->internal_count.fetch_add(-1, std::memory_order_relaxed) == 1) {
                ptr->internal_count.load(std::memory_order_acquire);
                delete ptr;
            }
        }
    }
};

```
